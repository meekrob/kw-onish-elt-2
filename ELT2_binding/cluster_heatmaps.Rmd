---
title: "Clustering of modENCODE/Reinke ChIP-seq peaks"
author: "DC King - Onish lab"
date: "Fall 2020"
output:
  pdf_document: default
  word_document:
    keep_md: true
---

```{r setup, include=FALSE}
options(repos = c(CRAN = "http://cran.rstudio.com"))

# checks for packages, run install if necessary 
source("scripts/check_for_install_deps.R",echo = F) 
library(pheatmap, quietly=T, warn.conflicts = F)
library(stringr, quietly=T, warn.conflicts = F)
library(reshape2, quietly=T, warn.conflicts = F)
library(ggplot2, quietly=T, warn.conflicts = F)
library(ggExtra, quietly=T, warn.conflicts = F)
library(RColorBrewer, quietly=T, warn.conflicts = F) # for pheatmap
library(GenomicRanges, quietly=T, warn.conflicts = F)
library(biomaRt, quietly=T, warn.conflicts = F)
library(ChIPpeakAnno, quietly=T, warn.conflicts = F)
library(topGO, quietly=T, warn.conflicts = F)
library(dplyr, quietly=T, warn.conflicts = F)
library(UpSetR, quietly=T, warn.conflicts = F)
library(knitr, quietly=T, warn.conflicts = F)
library(grid, quietly=T, warn.conflicts = F)
library(VennDiagram, quietly=T, warn.conflicts = F)
library(plyranges, quietly=T, warn.conflicts = F) # tidy the GRange datatypes
library(parallel)
library(future)
library(clusterProfiler)
library(org.Ce.eg.db)
library(ggrepel)

commathou = function(num) {
  format(num, big.mark = ",")
}
```

## Script version and versions

This repo is from ``bash git remote -v```. Using ``r R.version.string``.

```{bash repo version, include=FALSE, echo=FALSE}

git remote -v
git log -n 1
git status -s | grep -v '^?'
#git diff cluster_heatmaps.Rmd
```
## Process data

The source data is a BED file corresponding to the basewise UNION of LE, L1, and L3 IDR peak files, run through an aggregate function (mod'd javaGenomicToolkit) that calculates summary information for each of the above ranges.

The original IDR peaks are rescanned to determine the composition of each peak.

```{r get-data, echo=FALSE,cache=TRUE}
# IDR peaks

# narrowPeak is bedlike. Each line contains - 
# The comprehensive range of two overlapping peaks.
# The comprehensive peak summit.
# The summit and ranges of the individual peaks.
# Score information.
source('scripts/makeGRangesFromNarrowPeak.R') # this script retains the extra columns and drops unused ones
#L1_IDR = makeGRangesFromNarrowPeak('L1_1_L1_2.IDR_0.05.narrowPeak')
L1_IDR = makeGRangesFromNarrowPeak('redux/L1.narrowPeak')
L1_npeaks = length(L1_IDR)
#LE_IDR = makeGRangesFromNarrowPeak('LE_1_LE_2.IDR_0.05.narrowPeak')
LE_IDR = makeGRangesFromNarrowPeak('redux/LE.narrowPeak')
LE_npeaks = length(LE_IDR)
#L3_IDR = makeGRangesFromNarrowPeak('L3_1_L3_2.IDR_0.05.narrowPeak')
L3_IDR = makeGRangesFromNarrowPeak('redux/L3.narrowPeak')
L3_npeaks = length(L3_IDR)
# Union of all IDR output, with peak maxes assigned via my modification of javaGenomicsToolkit https://github.com/meekrob/java-genomics-toolkit
#df = read.table("allStagesUNION.IDR_0.05.sorted.bed_s.df", header=T, sep="\t")
df = read.table("redux/allStagesUnion.bed.df", header=T, sep="\t")
chroms <- Seqinfo(c('chrI', 'chrII', 'chrIII', 'chrIV', 'chrV', 'chrX', 'chrM'),
                    c(15072434, 15279421, 13783801, 17493829, 20924180, 17718942, 13794),
                    rep(FALSE,7),
                    rep("chr11",7))
suppressWarnings({ # 3 out-of-bound ranges. This might be generated by IDR or SPP procedures.
  dfG = makeGRangesFromDataFrame(df, 
                                 keep.extra.columns = T, 
                                 ignore.strand = T, 
                                 seqinfo=chroms,
                                 starts.in.df.are.0based = T)
})
dfG = trim(dfG)

dfG$LE_IDR = FALSE
dfG$L1_IDR = FALSE
dfG$L3_IDR = FALSE
```


```{r manage-data, echo=FALSE,cache=T}

#### Mark which IDR peaks contributed to the union
LE_verify = GenomicRanges::findOverlaps(LE_IDR, dfG, type="any")
L1_verify = GenomicRanges::findOverlaps(L1_IDR, dfG, type="any")
L3_verify = GenomicRanges::findOverlaps(L3_IDR, dfG, type="any")
dfG$LE_IDR[ to(LE_verify) ] <- TRUE
dfG$L1_IDR[ to(L1_verify) ] <- TRUE
dfG$L3_IDR[ to(L3_verify) ] <- TRUE

source('scripts/r_isect_union.R')
summit_agreement = score_peak_summit_agreement(dfG, LE_IDR, L1_IDR, L3_IDR)
dfG$LE_peak_1_summit = summit_agreement$LE_peak_1_summit
dfG$LE_peak_2_summit = summit_agreement$LE_peak_2_summit
dfG$L1_peak_1_summit = summit_agreement$L1_peak_1_summit
dfG$L1_peak_2_summit = summit_agreement$L1_peak_2_summit
dfG$L3_peak_1_summit = summit_agreement$L3_peak_1_summit
dfG$L3_peak_2_summit = summit_agreement$L3_peak_2_summit
dfG$summit_agreement = summit_agreement$summit_agreement

# collect some variables 
IDR_sets = list(LE_IDR=LE_IDR,L1_IDR=L1_IDR,L3_IDR=L3_IDR,LE_verify=LE_verify,L1_verify=L1_verify,L3_verify=L3_verify)
rm(LE_IDR,L1_IDR,L3_IDR,LE_verify,L1_verify,L3_verify)

# Remove the unused javaGenomicsToolkit columns (min,mean,etc.), and cut out the filename portions
# df -> df_max
df %>% dplyr::select(starts_with('max')) %>%
  dplyr::rename(
    max_log_LE_1_minus_log_LE_input=max_06_SIGNAL.LE_1_minus_input.bw,  
         max_log_LE_2_minus_log_LE_input=max_06_SIGNAL.LE_2_minus_input.bw,
         max_log_L1_1_minus_log_L1_input=max_06_SIGNAL.L1_1_minus_input.bw, 
         max_log_L1_2_minus_log_L1_input=max_06_SIGNAL.L1_2_minus_input.bw, 
         max_log_L3_1_minus_log_L3_input=max_06_SIGNAL.L3_1_minus_input.bw, 
         max_log_L3_2_minus_log_L3_input=max_06_SIGNAL.L3_2_minus_input.bw 

         )  %>%
  dplyr::select( # to reorder them
    max_log_LE_1_minus_log_LE_input,
    max_log_LE_2_minus_log_LE_input,
    max_log_L1_1_minus_log_L1_input,
    max_log_L1_2_minus_log_L1_input,
    max_log_L3_1_minus_log_L3_input,
    max_log_L3_2_minus_log_L3_input
  ) -> df_max

# The same operation for Genomic Ranges metadata
# dfG -> dfG_max
dfG_metadata <- mcols(dfG)
dfG_metadata %>% as.data.frame() %>% dplyr::select(-starts_with('min'), -starts_with('mean'), -starts_with('N')) %>%
  dplyr::rename(
         L1_1=max_06_SIGNAL.L1_1_minus_input.bw, 
         L1_2=max_06_SIGNAL.L1_2_minus_input.bw, 
         L3_1=max_06_SIGNAL.L3_1_minus_input.bw, 
         L3_2=max_06_SIGNAL.L3_2_minus_input.bw, 
         LE_1=max_06_SIGNAL.LE_1_minus_input.bw,  
         LE_2=max_06_SIGNAL.LE_2_minus_input.bw) %>%
  dplyr::select( # to reorder them
    LE_1,
    LE_2,
    L1_1,
    L1_2,
    L3_1,
    L3_2,
    ends_with("IDR"),
    ends_with("summit"),
    summit_agreement
  ) -> 
  dfG_metadata_max
# not changing the row count, can map back onto dfG
dfG_max = dfG
mcols(dfG_max) <- dfG_metadata_max


position_columns = c("chrom","chromStart","chromEnd","ID")
# make numeric, with 

df_max %>% as.matrix() -> data6d

df_max %>% dplyr::mutate(
  LE=(max_log_LE_1_minus_log_LE_input+max_log_LE_2_minus_log_LE_input)/2,
  L1=(max_log_L1_1_minus_log_L1_input+max_log_L1_2_minus_log_L1_input)/2,
  L3=(max_log_L3_1_minus_log_L3_input+max_log_L3_2_minus_log_L3_input)/2
  ) %>% dplyr::select(LE,L1,L3) -> data3d

nrow(data3d)
```

## Genomic properties of peaks

```{r chromosome distribution, echo=FALSE, cache=TRUE}
chromlens=seqlengths(seqinfo(dfG))

positionals = data.frame(position=start(dfG),index=seq_along(start(dfG)), chrom=seqnames(dfG))
positionals = positionals %>% filter(chrom != 'chrM')
positionals$relpos = positionals$position / chromlens[positionals$chrom]

npeaks_by_chrom = table(as.character(positionals$chrom))
npeaks_vs_chromlen = data.frame(
  npeaks=as.numeric(npeaks_by_chrom), # as.numeric, otherwise it splits into npeaks.Var1,npeaks.Freq
           chromlens=chromlens[names(npeaks_by_chrom)] # crossreference by name
  )
ggplot(npeaks_vs_chromlen, aes(y=npeaks,x=chromlens, label=rownames(npeaks_vs_chromlen))) + geom_point() +geom_smooth(formula='y~x',method="lm") + geom_text_repel() + ggtitle("Number of peaks versus chromosome length") + xlab("chromosome length") + ylab("# peaks called")

ggplot(positionals, aes(x=relpos)) + geom_density(adjust=.5)  + facet_wrap(vars(chrom)) + ggtitle("Peaks favor chromosome centers") + xlab("Relative position of peak along chromosome") + ylab("peak density")
```
Peaks are equally distributed across the nuclear chromosomes, accounting for the chromosome size in bases.

Peaks favor the centers of chromosomes. 

```{r overlap plots, echo=FALSE, cache=TRUE}
LEL1L3=ifelse(as.matrix(mcols(dfG_max))[,c('LE_IDR','L1_IDR','L3_IDR')],1,0)

## Venn diagram
area1 = sum(LEL1L3[,1] == 1)
area2 = sum(LEL1L3[,2] == 1)
area3 = sum(LEL1L3[,3] == 1)

# Stage-specific counts of peaks called. Not needed for draw.venn, but used in text
n100 = sum( LEL1L3[,1] == 1 & LEL1L3[,2] == 0 & LEL1L3[,3] == 0)
n020 = sum( LEL1L3[,2] == 1 & LEL1L3[,1] == 0 & LEL1L3[,3] == 0)
n003 = sum( LEL1L3[,3] == 1 & LEL1L3[,2] == 0 & LEL1L3[,1] == 0)

n120 = sum( LEL1L3[,1] == 1 & LEL1L3[,2] == 1 & LEL1L3[,3] == 0)
n023 = sum( LEL1L3[,2] == 0 & LEL1L3[,1] == 1 & LEL1L3[,3] == 1)
n103 = sum( LEL1L3[,3] == 1 & LEL1L3[,2] == 0 & LEL1L3[,1] == 1)

# two-way overlaps
n23 = sum( LEL1L3[,2] == 1 & LEL1L3[,3] == 1)
n12 = sum(LEL1L3[,1] == 1 & LEL1L3[,2] == 1 )
n13 = sum(LEL1L3[,1] == 1  & LEL1L3[,3] == 1)

# three-way intersection
n123 = sum(LEL1L3[,1] == 1 & LEL1L3[,2] == 1 & LEL1L3[,3] == 1)

LE_purple = "#7570B3" # Chetwode blue
L1_green = "#1B9E77" # Elf green 
L3_orange = "#D95F02" # Tawny
Increasing_pink = "#E7298A" # Deep Cerise

grid.newpage()
# title <- textGrob("Peaks", y=unit(0.5,"npc") + 0.5*h, 
#                   vjust=0, gp=gpar(fontsize=20))
grid.draw(
  draw.triple.venn(
    area1, area2, area3, n12, n23, n13, n123,
    fill=c(LE_purple,L1_green,L3_orange), # reflects the colors used in clusters/categories
    category=c("LE","L1","L3")
    )
  )

pdf("Peak_overlap_Venn.pdf") 
grid.draw(
  draw.triple.venn(
    area1, area2, area3, n12, n23, n13, n123,
    fill=c(LE_purple,L1_green,L3_orange), # reflects the colors used in clusters/categories
    category=c("LE","L1","L3")
    )
  )
dev.off()


overlap = function(under, over,a=.5) {
    r1 <- strtoi(substr(under, 2, 3), base = 16)
    r2 <- strtoi(substr(over, 2, 3), base = 16)
    g1 <- strtoi(substr(under, 4, 5), base = 16)
    g2 <- strtoi(substr(over, 4, 5), base = 16)
    b1 <- strtoi(substr(under, 6, 7), base = 16)
    b2 <- strtoi(substr(over, 6, 7), base = 16)
    
    
    result <- rgb(a * r2 + (1 - a) * r1,
                  a * g2 + (1 - a) * g1,
                  a * b2 + (1 - a) * b1,
                  alpha = 255,
                  max=255)
    return(result)
}
LEL1_color = overlap(LE_purple,L1_green)
L1L3_color = overlap(L1_green,L3_orange)
LEL3_color = overlap(LE_purple,L3_orange)
all_color = overlap(overlap(LEL1_color, L1L3_color), LEL3_color)

# upset plot
upset(as.data.frame(LEL1L3),
      order.by = "degree", decreasing=F,
      queries=list(
        list(
          query=intersects,
          params=list("LE_IDR"),
          color=LE_purple,
          active=T
        ),
        list(
          query=intersects,
          params=list("L1_IDR"),
          color=L1_green,
          active=T
        ),
        list(
          query=intersects,
          params=list("L3_IDR"),
          color = L3_orange,
          active=T
        ),
        list(
          query=intersects,
          params=list("LE_IDR","L1_IDR"), 
          color = LEL1_color,
          active=T),
      list(
          query=intersects,
          params=list("LE_IDR","L3_IDR"), 
          color = LEL3_color,
          active=T),
      list(
          query=intersects,
          params=list("L1_IDR","L3_IDR"), 
          color = "#A0682A",
          active=T),
      list(
          query=intersects,
          params=list("LE_IDR","L1_IDR","L3_IDR"), 
          color = "#926134",
          active=T)
        )
)
```

The overlap between the different IDR-vetted peaks is not uniform. Individually, the number of peaks called at each stage increases through developmental time, ranging from `r commathou(LE_npeaks)`, `r commathou(L1_npeaks)`, and `r commathou(L3_npeaks)` for late embryo, L1, and L3, respectively. The total number of merged peaks is `r commathou(length(dfG))`. 
`r commathou(n003)` are stage-specific; `r commathou(n120+n023+n103)` are called in at least two stages.
A large class is present in all three stages, 
`r commathou(n123)`, representing `r sprintf('%.0f%%',100*n123/nrow(df_max))` of total. 

### current wording in text
The overlap between the different IDR-vetted peaks at different stages is not uniform. Individually, the number of peaks called at each stage increases through developmental time, ranging from `r commathou(LE_npeaks)`, to `r commathou(L1_npeaks)`, to `r commathou(L3_npeaks)` for LE, L1, and L3, respectively. The total number of merged peaks is `r commathou(length(dfG))`. The largest individual class is the set of `r commathou(n003)` peaks called in L3 without LE or L1 counterparts by overlapping position. A large class is present in all three stages, `r commathou(n123)`, representing `r sprintf('%.0f%%',100*n123/nrow(df_max))` of total.

### Post-scaling of data

Now the quantitative data represents 3 timepoints, 2 replicates each. Each value is the input and read-depth normalized pileups (signal) computed per basepair. The maximum value within a peak is the value used. There are `r format(nrow(data3d), big.mark = ',')` peaks, (and therefore rows).

Next we want to filter the lesser 5% invariant rows, and then normalize the values by row.

```{R normalization, echo=FALSE,cache=TRUE}

# perform normalization on 3d
peaks3d_sd = apply(data3d, 1, sd)
peaks3d_mu = apply(data3d, 1, mean)
peaks3d_std = (data3d - peaks3d_mu) /  peaks3d_sd

# perform normalization on 6d (data)
peaks6d_sd = apply(data6d, 1, sd)
peaks6d_mu = apply(data6d, 1, mean)
# normalize by row
peaks6d_std = (data6d- peaks6d_mu) /  peaks6d_sd

# change filenames to shorter labels
colnames(peaks6d_std) <- c("LE_1", "LE_2", "L1_1", "L1_2", "L3_1","L3_2")

# changing versus not-changing
q.peaks6d_zeroed_nans_sd = function(q) { quantile(peaks6d_sd, q)}
q.peaks3d_zeroed_nans_sd = function(q) { quantile(peaks3d_sd, q)}

THRESHOLD = .05

# make the text conversions consistent
TXT_THRESHOLD = sprintf("%.3f", THRESHOLD)

# Enforce stdev-passing peaks and "all IDR" as part of the threshold
# w/reps
threshold6d_q = q.peaks6d_zeroed_nans_sd(THRESHOLD)
threshold6d_ix = peaks6d_sd > threshold6d_q
# to restrict to all IDR only
#threshold6d_ix = dfG$LE_IDR & dfG$L1_IDR & dfG$L3_IDR & threshold6d_ix
threshold6d_x = peaks6d_std[threshold6d_ix,]
# w/reps avg'd
threshold3d_q = q.peaks3d_zeroed_nans_sd(THRESHOLD)
threshold3d_ix = peaks3d_sd > threshold3d_q
# to restrict to all IDR only
#threshold3d_ix = dfG$LE_IDR & dfG$L1_IDR & dfG$L3_IDR & threshold3d_ix
threshold3d_x = peaks3d_std[threshold3d_ix,]

include6d_x = threshold6d_x
include3d_x = threshold3d_x

# clean up the environment some more
thresholded_data = list( w_reps = list(threshold6d_q=threshold6d_q,
                                       threshold6d_ix=threshold6d_ix,
                                       threshold6d_x=threshold6d_x,
                                       include6d_x=include6d_x),
                         reps_avd = list(threshold3d_q=threshold3d_q,
                                         threshold3d_ix=threshold3d_ix,
                                         threshold3d_x=threshold3d_x,
                                         include3d_x=include3d_x),
                         THRESHOLD=THRESHOLD,
                         TXT_THRESHOLD = sprintf("%.3f", THRESHOLD))

rm(threshold6d_q,threshold6d_ix,threshold6d_x,include6d_x,
   threshold3d_q,threshold3d_ix,threshold3d_x,include3d_x,
   THRESHOLD,TXT_THRESHOLD)
```




### K-means clustering

Perform K-means on the peaks that vary throughout the timecourse.

```{r cluster, echo=FALSE, cache=TRUE}
attach(thresholded_data)
source('scripts/reorder_kmeans.R')
nclust=4

# scree
wss=0
for (i in 2:20) {
  wss[i] = kmeans(reps_avd$include3d_x, centers = i)$tot.withinss
  
}
plot(2:20,wss[2:20],type='b',xlab='number of clusters', ylab='total within groups sum-of-squares', main="Skree plot for cluster number")

label=paste(
  sprintf("kmeans clusters at std. dev. > %.3f,", 
          reps_avd$threshold3d_q), 
          "(excludes lower ", sprintf("%.1f%%)", 
          THRESHOLD*100))
clusters = list()

set.seed(31415)
pobj = pheatmap(reps_avd$include3d_x, kmeans=nclust, cluster_rows=F, cluster_cols = F, main=label)
clusters$kmeans_on3d_k4 = reorder_kmeans(pobj$kmeans)
k4_explained_variance = clusters$kmeans_on3d_k4$betweenss/clusters$kmeans_on3d_k4$totss

heatmap_color = colorRampPalette(rev(brewer.pal(n = 7, name ="RdYlBu")))(100)
pheatmap(reps_avd$include3d_x[order(clusters$kmeans_on3d_k4$cluster),], cluster_rows=F, cluster_cols=F, color=heatmap_color, show_rownames=F)

set.seed(31415)
clusters$kmeans_on3d_k6 = reorder_kmeans(kmeans(reps_avd$include3d_x,6))
k6_explained_variance = clusters$kmeans_on3d_k6$betweenss/clusters$kmeans_on3d_k6$totss


# trend plot with 4 clusters
clusters$k4_trends = clusters$kmeans_on3d_k4$centers
rownames(clusters$k4_trends) <- c("LE-specific", "Post embryonic", "L3-high","Increasing")

clusters$k4_trends_long = melt(clusters$k4_trends)
colnames(clusters$k4_trends_long) <- c("description", "stage", "center")

label=paste(sprintf("%d cluster trends at std. dev. > %.3f,", nrow(clusters$k4_trends), reps_avd$threshold3d_q), "(excludes lower ", sprintf("%.1f%%)", THRESHOLD*100))
figure_colors = scale_colour_manual(values=c("#7570B3","#1B9E77","#D95F02","#E7298A"))
print(
  ggplot(clusters$k4_trends_long, 
         aes(x=stage,y=center, 
             group=description,
             colour=description)) + 
    geom_line(size = 2) + 
    labs(title="Kmeans cluster centers (k=4)",
         subtitle=sprintf("%.1f%% variance explained",100*k4_explained_variance),
         y = "cluster center (Z)", 
         x = "developmental stage") + 
    figure_colors)

# for the figure, separate out the groups into a separate plot, lay them out vertically,
# and prevent the domain from expanding
print( # k4stacked.pdf, scrunch the "Plots" display in the right panel all the way down to real dimensions you expect in the 
       # Illustrator file.
    ggplot(clusters$k4_trends_long, 
           aes(x=stage,y=center, 
               group=description,
               colour=description)) + 
        geom_line(size = 2) + 
        labs(title="Kmeans cluster centers (k=4)", 
             y = "cluster center (Z)", 
             x = "developmental stage") + 
      figure_colors + facet_grid(description ~ .) +  
      theme(legend.position = "none",
            strip.text.y = element_blank(), # omit facet label
            aspect.ratio=1.4787/3,
            panel.spacing=unit(.7,"cm"),
            panel.background=element_rect(fill='white'),
            panel.grid.minor.y=element_line(colour='black',linetype = 'dashed',size=.5),
            panel.grid.major.y=element_line(colour='black',linetype = 'solid',size=.75), 
            panel.grid.major.x=element_line(colour='grey',linetype = 'solid',size=.5)) +
      scale_x_discrete(expand=rep(0,4)) + 
      scale_y_continuous(breaks = c(-1,0,1),
                         minor_breaks=c(-.5,.5)
                         )
)

# trend plot with 6 clusters
clusters$k6_trends = as.data.frame(clusters$kmeans_on3d_k6$centers)
clusters$k6_trends$label <- sprintf("%d (%d)", 1:6, clusters$kmeans_on3d_k6$size)

k6_trends_long = melt(clusters$k6_trends)
k6_trends_long$label = factor(k6_trends_long$label, levels = clusters$k6_trends$label)
colnames(k6_trends_long) <- c("cluster","stage","center")

figure_colors = scale_colour_manual(name="cluster Id (size)", 
                                      values=c("#7570B3", "#A6D854", "#1B9E77","#D95F02","#E7298A","#E7298A")
                                      )
print(
  ggplot(k6_trends_long, 
         aes(x=stage,y=center, 
             group=cluster,
             colour=cluster)) + 
    geom_line(size = 1.5) + 
    labs(title="Kmeans cluster centers (k=6)",
         subtitle=sprintf("%.1f%% variance explained",100*k6_explained_variance),
         y = "cluster center (Z)", 
         x = "developmental stage") + 
    figure_colors + 
    theme(panel.background=element_rect(fill='#E6E6E6'))
    
  )

source('scripts/kweights.R')
# The profiler points to rbind in the euclid/dist call as the main time sync.
# Maybe this can be avoided by pasting the cluster centers onto the data (a single call to rbind),
# then running dist() on the resulting table. The euclid function would then access the appropriate
# rows of the resultant output, called by weight_f(), which is applied over each center for each row
# of data, and summed inside row_func, which returns the reciprocal as the value of w[i][j].
clusters$k4weights = kweights(reps_avd$include3d_x, clusters$kmeans_on3d_k4$cluster, clusters$kmeans_on3d_k4$centers)
# laptop:
#    user  system elapsed 
#   17.295   0.227  18.562 
#clusters$k6weights = kweights(reps_avd$include3d_x, clusters$kmeans_on3d_k6$cluster, clusters$kmeans_on3d_k6$centers)
clusters$k6weights = rep(1,length(clusters$kmeans_on3d_k6$cluster))

# The standard heatmaps. See https://stackoverflow.com/questions/36852101/r-legend-title-or-units-when-using-pheatmap for 
# getting the data out manually.
pheatmap(reps_avd$include3d_x[order(clusters$kmeans_on3d_k4$cluster,-clusters$k4weights),], cluster_rows=F, cluster_cols=F, color=heatmap_color, show_rownames=F)
pheatmap(reps_avd$include3d_x[order(clusters$kmeans_on3d_k6$cluster,-clusters$k6weights),], cluster_rows=F, cluster_cols=F, color=heatmap_color, show_rownames=F)

if(F)
{
  pdf("fig2_heatmap.pdf",width=7, height=3)
pheatmap(t(reps_avd$include3d_x[order(clusters$kmeans_on3d_k4$cluster, -clusters$k4weights),]), cluster_rows=F, cluster_cols=F, color=heatmap_color, show_colnames=F)
dev.off()
}
# add clusters and weights to GenomicRanges object
dfG_max$k4cluster = 0
dfG_max$k6cluster = 0
dfG_max$k4weights = 0
dfG_max$k6weights = 0
dfG_max$k4cluster[reps_avd$threshold3d_ix] <- clusters$kmeans_on3d_k4$cluster
dfG_max$k4weights[reps_avd$threshold3d_ix] = clusters$k4weights
dfG_max$k6cluster[reps_avd$threshold3d_ix] <- clusters$kmeans_on3d_k6$cluster
dfG_max$k6weights[reps_avd$threshold3d_ix] = clusters$k6weights

```

### Partition the IDR peaks by the cluster assigned to their counterpart in the union set
```{r idr-by-cluster}
IDR_sets = within(IDR_sets,{
  dfG_max$k4cluster[ to(LE_verify) ] ->LE_IDR$cluster
  dfG_max$k4cluster[ to(L1_verify) ] ->L1_IDR$cluster
  dfG_max$k4cluster[ to(L3_verify) ] ->L3_IDR$cluster
  LE_IDR$called.stage = "LE"
  L1_IDR$called.stage = "L1"
  L3_IDR$called.stage = "L3"
})


IDR_concat = c(IDR_sets$LE_IDR,IDR_sets$L1_IDR,IDR_sets$L3_IDR)
# remove chrM
IDR_concat = IDR_concat[ seqnames(IDR_concat) != 'chrM']
IDR_by_cluster = split(IDR_concat, IDR_concat$cluster) # returns GRangesList
total_coverage = sum(unlist(lapply(coverage(IDR_by_cluster), sum)))  
nr_coverage = sum(unlist(lapply(coverage(reduce(IDR_by_cluster)), sum)))

total_coverage/nr_coverage

# separate and save IDR peaks mapped by cluster
for (clust in names(IDR_by_cluster)) {
  last_col = ncol(mcols(IDR_by_cluster[[clust]])) # yikes
  fname = paste("IDR_", clust, ".bed", sep='')
  gr = sort(IDR_by_cluster[[clust]])
  nr_gr = reduce(gr)
  write.table(gr[,3:last_col], fname, row.names=F,col.names=F,quote=F,sep="\t")
  
  cov_gr = sum(sum(coverage(gr)))
  cov_nr_gr = sum(sum(coverage(nr_gr)))
  cat(sprintf("%s overcount: %.2f\n", clust, cov_gr/cov_nr_gr))
  
}

```

```{r inspect a clump}
clust = '4'
compGR = findOverlaps(IDR_by_cluster[[clust]], reduce(IDR_by_cluster[[clust]]))
clumps = split(IDR_by_cluster[[clust]], subjectHits(compGR))
#system.time({clump_lens = unlist(lapply(clumps,length))}) # user: 14.294s
clump_lens = unlist(elementNROWS(clumps)) # user: .001s

biggestClump = which.max(clump_lens) # 12!!!!!!
#plotClump( clumps[biggestClump])
#clump = clumps[biggestClump]
clump = clumps[9]
source('scripts/GRplot.R')
{ # must run two plot cmds at once in Rmd
  plotdata = GRPlotNew(clump)
  plotIDR(plotdata$gr_ranges, plotdata$gr_data, plotdata$barheight)
}

```

```{r}
for (clust in names(IDR_by_cluster)) {
  IDR_clust = IDR_by_cluster[[clust]]
  # make a new set of ranges based on peak summit
  summits = start(IDR_clust) + IDR_clust$overall_summit_off
  # window size = flank * 2
  flank=12 # plus or minus
  s = summits - flank
  e = summits + flank
  centered_gr = GRanges(seqnames(IDR_clust), IRanges(start=s,end=e))
  nr_centered_gr = reduce(centered_gr)
  cov_centered_gr = sum(sum(coverage(centered_gr)))
  cov_nr_centered_gr = sum(sum(coverage(nr_centered_gr)))
  cat(sprintf("%s overcount: %.2f\n", clust, cov_centered_gr/cov_nr_centered_gr))
  # clump overlapping
  # clumped = findOverlaps(centered_gr, reduce(centered_gr))
  # break
}
# clumps = split(centered_gr, subjectHits(clumped))
# clump_lengths = unlist(elementNROWS(clumps))
```

### Prepare data structures to output bigBed files.

Custom tracks are served locally (but world-readable). The chunk currently also maps peaks to genes through the "scripts/getCodingGenes.R".

```{r format prepare BED, echo=FALSE,cache=TRUE}
dfG_max$LE_nonNormed = (dfG_max$LE_1 + dfG_max$LE_2)/2
dfG_max$L1_nonNormed = (dfG_max$L1_1 + dfG_max$L1_2)/2
dfG_max$L3_nonNormed = (dfG_max$L3_1 + dfG_max$L3_2)/2
dfG_max$LE_std = peaks3d_std[,1]
dfG_max$L1_std = peaks3d_std[,2]
dfG_max$L3_std = peaks3d_std[,3]

# if you do this, you can't rerun the chunk.
if (FALSE) {
  # drop the individual rep columns
  dfG_max$LE_1 = NULL
  dfG_max$LE_2 = NULL
  dfG_max$L1_1 = NULL
  dfG_max$L1_2 = NULL
  dfG_max$L3_1 = NULL
  dfG_max$L3_2 = NULL
}

float_precision_string = "%.3f"
peaksForBigBed = dfG_max
peaksForBigBed$LE_IDR = as.integer(dfG_max$LE_IDR)
peaksForBigBed$L1_IDR = as.integer(dfG_max$L1_IDR)
peaksForBigBed$L3_IDR = as.integer(dfG_max$L3_IDR)
peaksForBigBed$name = sprintf("ELT2peak%05d", 1:length(peaksForBigBed))
peaksForBigBed$k4weights = sprintf(float_precision_string, peaksForBigBed$k4weights)
peaksForBigBed$k4labels = c(
  "Not-changing or not IDR-passing",
  "LE-specific",
  "Post-embryonic",
  "L3-high",
  "Increasing"
)[peaksForBigBed$k4cluster + 1]
peaksForBigBed$k6weights = sprintf(float_precision_string, peaksForBigBed$k6weights)
peaksForBigBed$variance = apply(mcols(peaksForBigBed)[,c('LE_nonNormed','L1_nonNormed','L3_nonNormed')], 1, var)
peaksForBigBed$LE_nonNormed = sprintf(float_precision_string, peaksForBigBed$LE_nonNormed)
peaksForBigBed$L1_nonNormed = sprintf(float_precision_string, peaksForBigBed$L1_nonNormed)
peaksForBigBed$L3_nonNormed = sprintf(float_precision_string, peaksForBigBed$L3_nonNormed)
peaksForBigBed$LE_std = sprintf(float_precision_string, peaksForBigBed$LE_std)
peaksForBigBed$L1_std = sprintf(float_precision_string, peaksForBigBed$L1_std)
peaksForBigBed$L3_std = sprintf(float_precision_string, peaksForBigBed$L3_std)

source('scripts/getCodingGenes.R',echo=F)
system.time({annotatedPeaks = getCodingGenes(peaksForBigBed)})
attach(annotatedPeaks)
# this is now inaccurate after changing peaks (and their numbering)
#ra = read.table('data/genemapping.right.answers')
#cat("Inconsistent gene mappings:", sum(ap[ ra[[1]] ]$feature != ra[[3]]))
## See previous commits forspread sheet for spot-checks

mapping_breakdown = table(ap$insideFeature)
pie_labels = paste0(names(table(ap$insideFeature)), rep(" (",5), table(ap$insideFeature), rep(")",5))
pie(table(ap$insideFeature), labels=pie_labels, main="Gene features at or near ELT-2 occupied peaks", sub='The closest feature to a peak is mapped unless farther than 5KB.\n "insideFeature" means the peak completely encompasses the gene (might be a consequence of the merge).')

features_observed = table(ap$insideFeature)
# empirical data
if (file.exists('feature_mapping_empirical.tbl')) {
feature_table = readRDS("feature_mapping_empirical.tbl") %>% as_tibble() %>% dplyr::rename('unmapped ± 5Kb'='unmapped - 5Kb') %>% as.matrix()
ecdf_downstream = ecdf(feature_table[,'downstream'])
ecdf_includeFeature = ecdf(feature_table[,'includeFeature'])
ecdf_inside = ecdf(feature_table[,'inside'])
ecdf_overlapEnd = ecdf(feature_table[,'overlapEnd'])
ecdf_overlapStart = ecdf(feature_table[,'overlapStart'])
ecdf_unmapped = ecdf(feature_table[,'unmapped ± 5Kb'])

# empirical p-values of Obs < Emp
ecdf_includeFeature(features_observed['includeFeature'])
ecdf_overlapStart(features_observed['overlapStart'])
ecdf_overlapEnd(features_observed['overlapEnd'])
ecdf_downstream( features_observed['downstream'] )
ecdf_inside(features_observed['inside'])
ecdf_unmapped(features_observed['unmapped ± 5Kb'])

features_observed %>% melt() %>% dplyr::rename(feature=Var1,count=value) -> feat_obs_tbl

feature_tibble <-
  as_tibble(feature_table) %>% melt(
    measure.vars = 1:7,
    variable.name = "feature",
    value.name = "count"
  )
# arrange (relevel) in a 5' to 3' order, but put includeFeature all the way to the right
fiveToThree = levels(feature_tibble$feature)[c(7, 5, 3, 4, 1, 6, 2)]
feature_tibble %>% 
  mutate(feature = factor(feature, levels = fiveToThree)) -> refeature_tibble

ggplot(refeature_tibble, aes(x = count)) + 
  scale_x_continuous(name = "Frequency of feature mappings in randomized intervals", labels = scales::comma) +
  scale_y_continuous(name = "# of simulations (out of 9,000)", labels=scales::comma) +
  geom_histogram(binwidth = 10) + 
  facet_wrap( ~ feature) + 
  geom_vline(
       data = feat_obs_tbl,
       aes(xintercept = count),
       color = "red",
       size = .5) +
labs(title = expression(paste("Gene features at or near ELT-2 occupied peaks compared to randomizations across the genome")),
       caption = "Red line shows the frequency observed for the labelled feature in the ELT-2 occupied peaks")


ggplot(refeature_tibble, aes(x=feature,y=count)) + geom_boxplot() +geom_col(data = feat_obs_tbl,aes(x=feature,y=count),fill='red') + theme_classic()

melt(
  features_observed,
  measure.vars = 1:7,
  variable.name = "feature",
  value.name = "count"
) %>% as_tibble() %>% dplyr::rename(feature = Var1) %>% mutate(feature = factor(feature, levels = fiveToThree))

features_expected = colMeans(feature_table)
emp_chisq = function(n) { sum(((n-features_expected)^2)/features_expected)}
var_stat = apply(feature_table, 1, emp_chisq)
obs_var_stat = emp_chisq(features_observed)

ggplot(as_tibble(var_stat) %>% filter(value < 400), aes(x = value)) + 
  geom_rect(
    data=as_tibble(var_stat) %>% filter(value < 400),
    aes(
      xmin = quantile(value, prob = 0),
      xmax = quantile(value, prob = .99),
      ymin = 0,
      ymax = Inf
    ),
    fill = 'beige',
    alpha = .5
  ) +
  geom_histogram(
    bins = 30,
    fill = "white",
    color = "tan",
    alpha = 0.5
  ) + theme_classic() +
  labs(title = "Variability from empirical values",
      x = "Value of variability statistic", 
      y = "Number of permutations with given value",
      caption = "The shaded yellow area shows the lower 99% of\nstatistic values for the 9,000 permutations across the genome.\n7 extrema exhibited a statistic between 1000-1400.  The observed feature statistic is 2923; therefore, the empirical p-value is 0.")

ggplot(as_tibble(var_stat) %>% mutate(value = log(value)), aes(x = value)) + 
  geom_rect(
    data=as_tibble(var_stat) %>% mutate(value = log(value)),
    aes(
      xmin = quantile(value, prob = 0),
      xmax = quantile(value, prob = .999),
      ymin = 0,
      ymax = Inf
    ),
    fill = 'beige',
    alpha = .5
  ) +
  geom_histogram(
    bins = 30,
    fill = "white",
    color = "tan",
    alpha = 0.5
  ) + theme_classic() +
  geom_vline(aes(xintercept=log(obs_var_stat)),
       color = "red",
       size = .5) +
  labs(title = "Variability from empirical values",
      x = "log(value) of variability statistic", 
      y = "Number of permutations with given log(value)",
      caption = "The shaded yellow area shows the lower 99.9% of statistic values for the 9,000 \npermutations across the genome. 7 extrema yield a high variability statistic (log), \nranging between 7.37-7.42. However, the variability statistic for the ELT-2 occupied \npeaks is log(2923)=7.98 (red line), greater than observed in 9000 random permutations.\nTherefore, the empirical p-value is 0.")
}

peakSchema = "
table ELT2DynamicPeaks
\"ELT-2 Dynamic Peaks\"
(
string  chrom;		\"Reference sequence chromosome or scaffold\"
uint    chromStart;	\"Start position of feature on chromosome\"
uint    chromEnd;	\"End position of feature on chromosome\"
string  name;		\"Index of peak\"
string  WBID;   \"Wormbase ID\"
string mapping; \"How did it map to the gene?\"
uint  k4cluster;  \"Cluster assignment in kmeans = 4, 0 for not-changing\"
string  k4label; \"Description of the trend for cluster\"
string  k4weight;   \"Weight assigned to kmeans = 4 cluster assignment [0-1]\"
char[1] LE_IDR; \"0/1 IDR peak in Late embryo\"
char[1] L1_IDR; \"0/1 IDR peak in Stage 1 Larvae\"
char[1] L3_IDR; \"0/1 IDR peak in Stage 3 Larvae\"
)"
write(peakSchema, "peaks.as")




# make a dataframe that is in the same order as above
write.table(data.frame(as.character(seqnames(annotatedPeaks$ap)),
                       start(annotatedPeaks$ap),
                       end(annotatedPeaks$ap),
                       annotatedPeaks$ap$name,
                       annotatedPeaks$ap$feature,
                       annotatedPeaks$ap$insideFeature,
                       annotatedPeaks$ap$k4cluster,
                       annotatedPeaks$ap$k4labels,
                       annotatedPeaks$ap$k4weights,
                       annotatedPeaks$ap$LE_IDR,
                       annotatedPeaks$ap$L1_IDR,
                       annotatedPeaks$ap$L3_IDR#,
                       #annotatedPeaks$ap$summit_agreement
                    
                       ), "peaksForBigBed.bed",quote=F,row.names=F,col.names=F,sep="\t")
chrom.sizes = "chrV	20924180
chrX	17718942
chrIV	17493829
chrII	15279421
chrI	15072434
chrIII	13783801
chrM	13794"
write(chrom.sizes,"chrom.sizes")
```

### A BASH chunk, bedToBigBed

Run UCSC-user apps tools.

```{bash make bigBed, echo=FALSE, cache=TRUE}
# you must execute the above chunks first
# better figure out the PATH on your system
PATH=$PATH:/Users/david/bin/UCSC_userApps 
bedSort peaksForBigBed.bed peaksForBigBed.bed
bedToBigBed peaksForBigBed.bed chrom.sizes peaksForBigBed.bb -type=bed3+8 -tab -as=peaks.as -extraIndex=name
```

### Plot gene mapping stats.

Pie chart for the relative locations and counts of how the peaks mapped to genes.

```{r Get Coding Genes, echo=FALSE, cache=TRUE}
# annotatedPeaks assigned in previous chunk
attach(annotatedPeaks)
 # a pie chart with the breakdown of how the annotation happened
mapping_breakdown = table(ap$insideFeature)
breakdown = list(`upstream` = mapping_breakdown['upstream'] +
                              mapping_breakdown['overlapStart'],
                 `inside` = mapping_breakdown['inside'] + 
                            mapping_breakdown['includeFeature'],
                 `downstream` = mapping_breakdown['downstream'] + 
                                mapping_breakdown['overlapEnd'],
                 `unmapped` = mapping_breakdown['unmapped']
                 )

pie_labels = paste0(names(breakdown), rep(" (",4), unlist(breakdown), rep(")",4))
pie(unlist(breakdown), labels=pie_labels, main="Peaks mapping nearest to a gene", clockwise=T, init.angle=-90)

pdf("gene_mapping_pie.pdf")

pie_labels = paste0(names(breakdown), rep(" (",4), unlist(breakdown), rep(")",4))
pie(unlist(breakdown), labels=pie_labels, main="Peaks mapping nearest to a gene", clockwise=T, init.angle=-90)

dev.off()

# upset plot: identify set overlap by assigned value of k
clustersPerGene = table(ap$feature, ap$k4cluster)
wbid_rownames = rownames(clustersPerGene)
# some bool vectors
wbid_names_k0_bool = clustersPerGene[,'0'] > 0
wbid_names_k1_bool = clustersPerGene[,'1'] > 0
wbid_names_k2_bool = clustersPerGene[,'2'] > 0
wbid_names_k3_bool = clustersPerGene[,'3'] > 0
wbid_names_k4_bool = clustersPerGene[,'4'] > 0

wbid_clusters= list(k0=wbid_rownames[wbid_names_k0_bool],
                    k1=wbid_rownames[wbid_names_k1_bool],
                    k2=wbid_rownames[wbid_names_k2_bool],
                    k3=wbid_rownames[wbid_names_k3_bool], 
                    k4=wbid_rownames[wbid_names_k4_bool])

# Save lists of genes
for (wbk in names(wbid_clusters)) {
  print(length(wbid_clusters[[wbk]]))
  filename=sprintf("gene_lists/%s.Genes.txt",wbk)
  write.table(wbid_clusters[[wbk]], filename, quote=F, row.names = F, col.names = F)
}
write.table(unique(wbid_rownames), file="gene_lists/all.genes.txt",quote=F, row.names = F, col.names = F)
write.table(unique(wbid_rownames[!wbid_names_k0_bool]),file="gene_lists/all.dynamic.genes.txt",quote=F, row.names = F, col.names = F)

library(UpSetR);
wbid_clusters_fromlist = fromList(wbid_clusters) %>% dplyr::rename("not_changing" = k0, Embryo=k1, Larval= k2, L3=k3, Increasing=k4)

upset(wbid_clusters_fromlist, 
      sets=rev(c("Embryo", "Larval", "L3", "Increasing")), 
      mainbar.y.label = "Geneset intersections", 
      sets.x.label="# of genes in cluster",
      set_size.show=T,
      group.by="degree",
      text.scale=1.5, 
      keep.order = T,
      query.legend = "top", 
      nintersects=NA, 
      order.by = "freq", decreasing=T,
            queries=list(
        list(
          query.name = "Embryo-only",
          query=intersects,
          params=list("Embryo"),
          color=LE_purple,
          active=T
        ),
        list(
          query.name = "Larval-only",
          query=intersects,
          params=list("Larval"),
          color=L1_green,
          active=T
        ),
        list(
          query.name = "L3-only",
          query=intersects,
          params=list("L3"),
          color = L3_orange,
          active=T
        ),
        list(
          query.name = "Increasing-only",
          query=intersects,
          params=list("Increasing"),
          color = Increasing_pink,
          active=T
        ),
        list(
          query=intersects,
          params=list("Increasing","L3"),
          color = overlap(Increasing_pink,L3_orange),
          active=T
        ),
        list(
          query=intersects,
          params=list("Larval","Increasing"),
          color = overlap(L1_green,Increasing_pink),
          active=T
        ),
        list(
          query=intersects,
          params=list("Larval","L3"),
          color = overlap(L1_green,L3_orange),
          active=T
        ),
        list(
          query=intersects,
          params=list("Larval","L3","Increasing"),
          color="darkgoldenrod",
          active=T
        )
        )
      )

# breakdown of genes with multiple peaks
clustersPerGene_rowSums = rowSums(clustersPerGene)
multiple_peaks = clustersPerGene_rowSums > 1
sum(multiple_peaks) # 2280
breakdown=table(clustersPerGene_rowSums)
bp=barplot(table(clustersPerGene_rowSums), xlab="number of peaks mapped to a gene", ylab="number of genes", main="Genes tend to have a single peak mapped to them")
i=1; y=breakdown[i]; text(bp[i,1],y - strheight(y,srt=90)*1.9,srt=90, labels = y)
for (i in 2:10) { y=breakdown[i]; text(bp[i,1],y + strheight(y,srt=90)*1.66,srt=90, labels = y) }

# to create this plot in a separate file:
if (FALSE)
{
  pdf(file="fig1.pdf")
  print(ggplot(trends_ordered_long, aes(x=stage,y=center, group=description,colour=description )) + geom_line(size = 1.5) + labs(title=label, y = "cluster center (Z)", x = "developmental stage"))  
  dev.off()
}
```


```{r cluster-profiler, cache=TRUE}
annotatedPeaks$ap$k4labels[annotatedPeaks$ap$k4labels == "Post-embryonic"] <- "Larval"
annotatedPeaks$ap$k4labels = factor(annotatedPeaks$ap$k4labels, levels=c("LE-specific","Larval","L3-high","Increasing","Not-changing or not IDR-passing"))
lapply(split(annotatedPeaks$ap$feature, annotatedPeaks$ap$k4labels),unique) -> ap.split
lapply(ap.split, length)
sum(unlist(.Last.value))
gene.df <- lapply( ap.split, function(WBGeneID){ bitr(WBGeneID,
     fromType = "WORMBASE",
     toType = "ENTREZID",
     OrgDb = org.Ce.eg.db)})

lapply(gene.df,nrow)
sum(unlist(.Last.value))


gene.df$`Not-changing or not IDR-passing` = NULL
system.time(
{compareCluster(lapply(gene.df, function(x) x$ENTREZID),
               fun = "enrichGO",
               pvalueCutoff = 0.05,
               keyType = "ENTREZID",
               ont="MF",
               OrgDb = org.Ce.eg.db,
               pAdjustMethod = "BH",
               minGSSize = 5,
               maxGSSize = 150,
               readable=TRUE) -> compClust.MF})

# MF:
#   user  system elapsed 
# 16.542   2.653 128.106 
system.time(
{compareCluster(lapply(gene.df, function(x) x$ENTREZID),
               fun = "enrichGO",
               pvalueCutoff = 0.05,
               keyType = "ENTREZID",
               ont="BP",
               OrgDb = org.Ce.eg.db,
               pAdjustMethod = "BH",
               minGSSize = 5,
               maxGSSize = 150,
               readable=TRUE) -> compClust.BP})
# BP:
#   user  system elapsed 
# 30.142   5.171 149.272
# 33.919   6.138 236.847  (had readable=T)
# 26.847   4.398  39.339  (had readable=T)
# 27.766   4.445  40.864  (had readable=T)
# 32.690   5.623 107.306  
system.time(
{compareCluster(lapply(gene.df, function(x) x$ENTREZID),
               fun = "enrichGO",
               pvalueCutoff = 0.05,
               keyType = "ENTREZID",
               ont="CC",
               OrgDb = org.Ce.eg.db,
               pAdjustMethod = "BH",
               minGSSize = 5,
               maxGSSize = 150,
               readable=TRUE) -> compClust.CC})
```

```{r dotplot-MF, cache=TRUE}
compClust.simp = simplify(compClust.MF,cutoff=.25)
dotplot(compClust.simp, showCategory=10, includeAll=T,by="count") + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), axis.text.y=element_text(size=8))  + ggtitle("Molecular Function (GO)")
```

```{r dotplot-BP, cache=TRUE}
compClust.simp = simplify(compClust.BP,cutoff=.3)
dotplot(compClust.simp, showCategory=10, includeAll=T,by="count") + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), axis.text.y=element_text(size=8))  + ggtitle("Biological Process (GO)")
```

```{r dotplot-CC, cache=TRUE}
compClust.simp = simplify(compClust.CC,cutoff=.7)
dotplot(compClust.simp, showCategory=10, includeAll=T,by="count") + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), axis.text.y=element_text(size=8))  + ggtitle("Cellular Component (GO)")
```


```{r GO-dotplot, cache=TRUE }

dotplot(compClust.simp, showCategory=10, includeAll=T,by="count") + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), axis.text.y=element_text(size=8)) + ggtitle("GO (BP)")
```

```{r KEGG-dotplot, cache=TRUE }
c_eK<- compareCluster(geneClusters = lapply(gene.df, function(x) x$ENTREZID), 
                      fun="enrichKEGG", 
                      organism = "cel", 
                      pvalueCutoff = 0.05, 
                      keyType = "ncbi-geneid", 
                      pAdjustMethod = "BH", 
                      minGSSize = 5, 
                      maxGSSize = 150)
dotplot(c_eK) + ggtitle("KEGG pathways")

gene.df.ENTREZID = lapply(gene.df, function(x) x$ENTREZID)

kegg.readable = lapply(gene.df.ENTREZID, function(clust.entrez.ids) {
  as.data.frame(setReadable(
    enrichKEGG(clust.entrez.ids,
               organism = 'cel',
               keyType = 'ncbi-geneid'),
    OrgDb = org.Ce.eg.db,
    keyType = "ENTREZID"
  ))
})
# switch to kables
#View(kegg.readable$`LE-specific`) # empty
#View(kegg.readable$`Larval`)
#View(kegg.readable$`L3-high`)
#View(kegg.readable$Increasing)


```

### GO data and processing functions

Data is from paramart, the functions are necessary to make the topGO analysis easier to repeat across the clusters.

```{r GO Functions, echo=FALSE, cache=TRUE}
# get the annotations from PARASITE
if (! "paramart" %in% ls()) {
  system.time({paramart <- useMart("parasite_mart", dataset = "wbps_gene", host = "https://parasite.wormbase.org", port = 443)})}
if (! "WORMGO" %in% ls()) {
  # go to https://parasite.wormbase.org/biomart/martview/ to figure out the values to use for this
  system.time({WORMGO = biomaRt::getBM(
    mart = paramart,
    filter = c("species_id_1010","biotype"),
    value = list(species_id_1010="caelegprjna13758",biotype="protein_coding"),
    attributes = c(
      "wbps_gene_id",
      "external_gene_id",
      "go_accession",
      "go_name_1006",
      "go_linkage_type"
    )
  )}) 
}



# create an object where you can access all the GO terms that are assigned to a specific gene
geneID2GO <- by(WORMGO$go_accession, WORMGO$wbps_gene_id, function(x) as.character(x))

GOSummary<- function(GOdata, topNodes = 200) {
  
  resultClassic <- runTest(GOdata, algorithm = "classic", statistic = "fisher")
  resultElim <- runTest(GOdata, algorithm = "weight01", statistic = "fisher")
  
  GenTable(
    object=GOdata, 
    classicFisher = resultClassic,
    elim=resultElim,    
    orderBy="classicFisher",
    topNodes = topNodes
  ) -> tab
  # not sure where the conversion to char is happening. convert back
  tab$fisher = as.numeric(tab$classicFisher)
  tab$elim = as.numeric(tab$elim)
  return(tab)
}


mkGO = function(foreground_genes, background_genes) {
  # create a TRUE/FALSE list the size of background genes, TRUE if in foreground
  geneList = factor(as.integer(background_genes %in% foreground_genes))
  names(geneList) = background_genes
  BP.go = new("topGOdata", ontology='BP'
              , allGenes = geneList
              , annot = annFUN.gene2GO
              , gene2GO = geneID2GO)
  MF.go = new("topGOdata", ontology='MF'
              , allGenes = geneList
              , annot = annFUN.gene2GO
              , gene2GO = geneID2GO)
  CC.go = new("topGOdata", ontology='CC'
              , allGenes = geneList
              , annot = annFUN.gene2GO
              , gene2GO = geneID2GO)
  list(BP=BP.go,CC=CC.go,MF=MF.go)
}
```

### Perform GO-term enrichment analyses

Run the topGO analyses using the above functions. 

``` {r GO term analysis, include=FALSE, cache=TRUE}
attach(annotatedPeaks)

unique.clust_0_wbid = unique((annotatedPeaks$ap %>% filter(k4cluster == 0))$feature)
unique.clust_1_wbid = unique((annotatedPeaks$ap %>% filter(k4cluster == 1))$feature)
unique.clust_2_wbid = unique((annotatedPeaks$ap %>% filter(k4cluster == 2))$feature)
unique.clust_3_wbid = unique((annotatedPeaks$ap %>% filter(k4cluster == 3))$feature)
unique.clust_4_wbid = unique((annotatedPeaks$ap %>% filter(k4cluster == 4))$feature)

all.genes <- unique(as.character(WORMGO$wbps_gene_id))
unique.ap.wbid = unique(annotatedPeaks$ap$feature)
all.GO = mkGO(unique.ap.wbid, all.genes)


omigod = list()

genelists = list(
  all=list(fore=unique.ap.wbid, back=all.genes),
  K0=list(fore=unique.clust_0_wbid, back=unique.ap.wbid),
  K1=list(fore=unique.clust_1_wbid, back=unique.ap.wbid),
  K2=list(fore=unique.clust_2_wbid, back=unique.ap.wbid), 
  K3=list(fore=unique.clust_3_wbid, back=unique.ap.wbid), 
  K4=list(fore=unique.clust_4_wbid, back=unique.ap.wbid))

#library(parallelly)

cl <- makeClusterPSOCK(4) 
clusterExport(cl, list("GOSummary","unique.ap.wbid","mkGO","geneID2GO"))
system.time({
  omigod = parLapply(cl, genelists, function(set_genelist) {
      library(dplyr,quietly = T,warn.conflicts = F)
      library(topGO,quietly = T,warn.conflicts = F)
      dataset = mkGO(set_genelist$fore, set_genelist$back)
      BP.tab = GOSummary(dataset$BP) %>% filter(fisher < .05) %>% arrange(fisher) %>% mutate(DB="BP")
      CC.tab = GOSummary(dataset$CC) %>% filter(fisher < .05) %>% arrange(fisher) %>% mutate(DB="CC")
      MF.tab = GOSummary(dataset$MF) %>% filter(fisher < .05) %>% arrange(fisher) %>% mutate(DB="MF")
      # BP.tab = GOSummary(dataset$BP) %>% filter(elim < .05) %>% arrange(elim) %>% mutate(DB="BP")
      # CC.tab = GOSummary(dataset$CC) %>% filter(elim < .05) %>% arrange(elim) %>% mutate(DB="CC")
      # MF.tab = GOSummary(dataset$MF) %>% filter(elim < .05) %>% arrange(elim) %>% mutate(DB="MF")
      return(rbind(BP.tab, CC.tab, MF.tab))
  })
})
stopCluster(cl)

```

```{r ddd, cache=TRUE}

chip_v_genome_wide=mkGO(unique.ap.wbid, all.genes)
gBP = GOSummary(chip_v_genome_wide$BP,1000)
goID="GO:0050769"
neurogo=c('GO:0007218','GO:0033563','GO:0048665','GO:0097376','GO:0050769','GO:0007416','GO:0050769','GO:0003388')
gene.universe = genes(chip_v_genome_wide$BP)
go.genes <- genesInTerm(chip_v_genome_wide$BP, goID)[[1]]
sig.genes <- sigGenes(chip_v_genome_wide$BP)
my.group <- new("classicCount", testStatistic = GOFisherTest, name = "fisher",
                 allMembers = gene.universe, groupMembers = go.genes,
                 sigMembers = sig.genes)
contTable(my.group)
runTest(my.group)
```

```{r embryo-golists, cache=TRUE}
#dataset=mkGO(unique.clust_1_wbid,unique.ap.wbid)
dv_axon_guidance = 'GO:0033563'
neuron_fate_specification = 'GO:0048665'
neuropeptide_signalling_pathway = 'GO:0007218'
netrin_activated_signalling_pathway = 'GO:0038007'
GO_figure_neuro_terms = c(dv_axon_guidance,
                          neuron_fate_specification,
                          neuropeptide_signalling_pathway,
                          netrin_activated_signalling_pathway)

GO_figure_neuro_genes=c()
neuroterms=genesInTerm(dataset$BP, GO_figure_neuro_terms)
for (neuro_term in GO_figure_neuro_terms){
  neuroterms[[neuro_term]][neuroterms[[neuro_term]] %in% unique.clust_1_wbid] %>% c(GO_figure_neuro_genes) -> GO_figure_neuro_genes
}

cat("Genes in the neuron-related terms in the embryo VS ELT-2-dataset:\n")
WORMGO %>% filter(go_accession %in% GO_figure_neuro_terms) %>% filter(wbps_gene_id %in% GO_figure_neuro_genes)

```
We find some GO terms are enriched in some of the clusters versus the ELT-2 peaks at-large (all clusters). However, those terms *ARE NOT enriched* in ELT-2 peaks (all clusters) versus the genome (there are `r n_neuroterms_all` enriched).

For example, having `r n_0050769` genes annotated with the term "GO:0050769: positive regulation of neurogenesis" in the ELT-2 peaks is not *enriched* versus the whole genome (`r n_0050769_genome` genes).

However, having `r stats_0050769_k1$Significant` of those genes near Embryo-high peaks, relative to `r stats_0050769_k1$Expected` expected, gives a p-value of `r stats_0050769_k1$pval` using the elimination method implemented in topGO.


### Output GO term enrichment results. Also, write files to paste into Revigo analysis, which collapses terms.

Paste output two-column files (GO-term p-like-value) into the form at. http://revigo.irb.hr/index.jsp

```{r immune-go-lists}
innate_immune_response = 'GO:0045087'
dataset=mkGO(unique.clust_2_wbid,unique.ap.wbid)
immune_genes_chip = genesInTerm(dataset$BP, innate_immune_response)[[1]] # 170
immune_genes_larval = immune_genes_chip[immune_genes_chip %in% unique.clust_2_wbid] # 65
immune_peaks_chip = ap[ap$feature %in% immune_genes_chip] # 305

length(immune_genes_chip)
length(immune_genes_larval)
immune_peaks_larval = ap[ap$feature %in% immune_genes_larval] # 144
write.table(immune_peaks_larval$name, "peaklists/immune_peaks_larval.txt",row.names=F,col.names=F,quote=F)


immune_genes_L3 = immune_genes_chip[immune_genes_chip %in% unique.clust_3_wbid] # 31
immune_peaks_L3 = ap[ap$feature %in% immune_genes_L3] # 92
write.table(immune_peaks_L3$name, "peaklists/immune_peaks_L3.txt",row.names=F,col.names=F,quote=F)


immune_genes_increasing = immune_genes_chip[immune_genes_chip %in% unique.clust_4_wbid] # 248
immune_peaks_increasing = ap[ap$feature %in% immune_genes_increasing] # 92
write.table(immune_peaks_increasing$name, "peaklists/immune_peaks_increasing.txt",row.names=F,col.names=F,quote=F)


immune_genes_labelled = data.frame(embryo=immune_genes_chip %in% unique.clust_1_wbid)
immune_genes_labelled %>% 
  mutate(larval=(immune_genes_chip %in% unique.clust_2_wbid)) %>%
  mutate(L3=immune_genes_chip %in% unique.clust_3_wbid) %>%
  mutate(increasing=immune_genes_chip %in% unique.clust_4_wbid) -> immune_genes_labelled
rownames(immune_genes_labelled) <- immune_genes_chip

```

```{r GOterm-extracto-function}
zeroIfError = function(expr)
{
  suppressWarnings(tryCatch(expr, error=function(e){0}))
}

### here's the function
getGenesAndWBIDs_for_GOterm = function(term_id, GO_obj,ap.obj=ap)
{

  # WORMGO is the biomart result that contains the GO term name
  if( ! ("WORMGO" %in% ls(envir = .GlobalEnv)) ){
    stop("WORMGO is not in the global environment. Execute the 'GO functions' chunk.")
  }
  
  description=WORMGO %>% filter(go_accession == term_id) %>% select('go_name_1006') %>% unique %>% unlist 
  
  termGenes = c() # initialize
  if (zeroIfError(length(genesInTerm(dataset$MF, term_id)[[1]])) > 0)
  {
    termGenes = genesInTerm(dataset$MF, term_id)[[1]]
  } 
  else if (zeroIfError(length(genesInTerm(dataset$BP, term_id)[[1]])) > 0) 
  {
    termGenes = genesInTerm(dataset$BP, term_id)[[1]]
  }
  else if (zeroIfError(length(genesInTerm(dataset$CC, term_id)[[1]])) > 0) {
    termGenes = genesInTerm(dataset$CC, term_id)[[1]]
  }
  else {
    stop("GO term ID:",term_id, " not found in GO_obj")
  }
  
  peaks_ChIP = ap.obj[ap.obj$feature %in% termGenes]
  
  # get WBIDs for each cluster
  unique.clust_1_wbid = unique((ap.obj %>% filter(k4cluster == 1))$feature)
  unique.clust_2_wbid = unique((ap.obj %>% filter(k4cluster == 2))$feature)
  unique.clust_3_wbid = unique((ap.obj %>% filter(k4cluster == 3))$feature)
  unique.clust_4_wbid = unique((ap.obj %>% filter(k4cluster == 4))$feature)
  
  termGenes_notchanging = intersect(termGenes,unique.clust_0_wbid)
  termGenes_embryo = intersect(termGenes,unique.clust_1_wbid)
  termGenes_larval = intersect(termGenes,unique.clust_2_wbid)
  termGenes_L3 = intersect(termGenes,unique.clust_3_wbid)
  termGenes_increasing = intersect(termGenes,unique.clust_4_wbid)
  
  # tidy %>% .select can't get into the GRanges obj, so $ accessor outside of ()
  termPeaks_notchanging     = (ap.obj %>% filter(feature %in% termGenes_notchanging))$name
  termPeaks_embryo     = (ap.obj %>% filter(feature %in% termGenes_embryo))$name
  termPeaks_larval     = (ap.obj %>% filter(feature %in% termGenes_larval))$name
  termPeaks_L3         = (ap.obj %>% filter(feature %in% termGenes_L3))$name
  termPeaks_increasing = (ap.obj %>% filter(feature %in% termGenes_increasing))$name
  
  dir_friendly_GOID = stringr::str_replace(term_id, ":","")
  dir_friendly_desc = stringr::str_replace_all(description, " ", "_")
  dir_friendly_desc = stringr::str_replace_all(dir_friendly_desc, "/", "_")
  outdirname = sprintf("GO_split_lists/%s_%s", dir_friendly_GOID, dir_friendly_desc)
  if(! dir.exists(outdirname))
  {
    cat("writing directory:", outdirname)
    dir.create(outdirname)
  }
  wt = function(obj, filepath) { 
    write.table(obj, filepath,row.names=F,col.names=F,quote=F)
  }
  
  for (varstr in c("termGenes_notchanging", "termGenes_embryo", "termGenes_larval", 
                   "termGenes_L3", "termGenes_increasing",
                   "termPeaks_notchanging", "termPeaks_embryo", "termPeaks_larval", 
                   "termPeaks_L3", "termPeaks_increasing")) 
  {
      outobj=get(varstr)
      outpath = sprintf("%s/%s_%s.txt", outdirname, 
                        dir_friendly_GOID, 
                        str_replace(varstr, "term", ""))
      wt(outobj, outpath)
      cat("wrote", outpath, ".", length(outobj), "IDs.\n")
  }
    
}
```


```{r GO:0000981-TF-genelist}
DNA_transcription_factor_activity = 'GO:0000981'
TF_genes_chip = genesInTerm(dataset$MF, DNA_transcription_factor_activity)[[1]] 
TF_genes_embryo = TF_genes_chip[TF_genes_chip %in% unique.clust_1_wbid]
TF_genes_larval = TF_genes_chip[TF_genes_chip %in% unique.clust_2_wbid]
TF_genes_L3 = TF_genes_chip[TF_genes_chip %in% unique.clust_3_wbid]
TF_genes_increasing = TF_genes_chip[TF_genes_chip %in% unique.clust_4_wbid]

TF_peaks_chip = ap[ap$feature %in% TF_genes_chip] 

TF_peaks_embryo = ap[ap$feature %in% TF_genes_embryo] 
TF_peaks_larval = ap[ap$feature %in% TF_genes_larval] 
TF_peaks_L3 = ap[ap$feature %in% TF_genes_L3] 
TF_peaks_increasing = ap[ap$feature %in% TF_genes_increasing] 

write.table(TF_peaks_embryo$name, 
            "peaklists/TF_peaks_embryo.txt",
            row.names=F,col.names=F,quote=F)
write.table(TF_peaks_larval$name, 
            "peaklists/TF_peaks_larval.txt",
            row.names=F,col.names=F,quote=F)
write.table(TF_peaks_L3$name, 
            "peaklists/TF_peaks_L3.txt",
            row.names=F,col.names=F,quote=F)
write.table(TF_peaks_increasing$name, 
            "peaklists/TF_peaks_increasing.txt",
            row.names=F,col.names=F,quote=F)

```

``` {r GO output, echo=FALSE}
o=omigod
howmany_in_kable = 50

#kable(o[['all']] %>% select(-classicFisher,-'Rank in elim') %>% rename(pval=elim) %>% arrange(fisher) %>% head(howmany_in_kable), caption="Dataset versus genome")
kable(o[['all']] %>% select(-classicFisher,-'Rank in elim') %>% rename(pval=elim) %>% arrange(fisher), caption="Dataset versus genome")


kable(o[['K0']] %>% select(-classicFisher,-'Rank in elim') %>% rename(pval=elim) %>% arrange(pval) %>% head(howmany_in_kable), caption="Not changing versus whole dataset")


kable(o[['K1']] %>% select(-classicFisher,-'Rank in elim') %>% rename(pval=elim) %>% arrange(pval) %>% head(howmany_in_kable), caption="Embryo cluster versus whole dataset")

kable(o[['K2']] %>% select(-classicFisher,-'Rank in elim') %>% rename(pval=elim) %>% arrange(pval) %>% head(howmany_in_kable), caption="Larval cluster versus whole dataset")

kable(o[['K3']] %>% select(-classicFisher,-'Rank in elim') %>% rename(pval=elim) %>% arrange(pval) %>% head(howmany_in_kable), caption="L3 cluster versus whole dataset")

kable(o[['K4']] %>% select(-classicFisher,-'Rank in elim') %>% rename(pval=elim) %>% arrange(pval) %>% head(howmany_in_kable),
      caption="Increasing cluster versus whole dataset")
```


```{r write REVIGO tables, echo=FALSE}
write.table(o$all[,c(1,8)], "gene_lists/all.REVIGO/all.forREVIGO.txt",quote=F,col.names=F,row.names=F)
write.table(o$K0[,c(1,8)], "gene_lists/K0.REVIGO/K0.forREVIGO.txt",quote=F,col.names=F,row.names=F)
write.table(o$K1[,c(1,8)], "gene_lists/K1.REVIGO/K1.forREVIGO.txt",quote=F,col.names=F,row.names=F)
write.table(o$K2[,c(1,8)], "gene_lists/K2.REVIGO/K2.forREVIGO.txt",quote=F,col.names=F,row.names=F)
write.table(o$K3[,c(1,8)], "gene_lists/K3.REVIGO/K3.forREVIGO.txt",quote=F,col.names=F,row.names=F)
write.table(o$K4[,c(1,8)], "gene_lists/K4.REVIGO/K4.forREVIGO.txt",quote=F,col.names=F,row.names=F)
```




```{r filter by collapsed in REVIGO, echo=FALSE}

pdf("GOplots.pdf")

o[['all']] %>% rename(term_ID=GO.ID) -> okAll
bp=(read.csv('gene_lists/all.REVIGO/all.BP.69.csv') %>% filter(eliminated == 0) %>% select(term_ID))[[1]]
cc=(read.csv('gene_lists/all.REVIGO/all.CC.69.csv') %>% filter(eliminated == 0) %>% select(term_ID))[[1]]
mf=(read.csv('gene_lists/all.REVIGO/all.MF.69.csv') %>% filter(eliminated == 0) %>% select(term_ID))[[1]]

okAll%>% filter(term_ID %in% c(bp,cc,mf)) %>% arrange(`Rank in elim`,elim) %>% select(Term, term_ID, elim, DB) %>% head(20) %>% arrange(DB, elim) %>% mutate(nlogp=-log10(elim)) -> xx
xx$Term = factor(xx$Term, levels=rev(xx$Term))
ggplot(xx) + 
  geom_col(aes(nlogp,Term,fill=DB),color='black' )+ 
  theme(legend.position = 'none') +
  theme_bw() + scale_fill_manual("ontology",values=c('#404040','grey','white')) +
  ggtitle("Terms enriched in genes mapped to all peaks (versus genome)")



o[['K0']] %>% rename(term_ID=GO.ID) -> ok0

bp=(read.csv('gene_lists/K0.REVIGO/K0.BP.69.csv') %>% filter(eliminated == 0) %>% select(term_ID))[[1]]
cc=(read.csv('gene_lists/K0.REVIGO/K0.CC.69.csv') %>% filter(eliminated == 0) %>% select(term_ID))[[1]]
mf=(read.csv('gene_lists/K0.REVIGO/K0.MF.csv') %>% filter(eliminated == 0) %>% select(term_ID))[[1]]

ok0 %>% filter(term_ID %in% c(bp,cc,mf)) %>% arrange(`Rank in elim`,elim) %>% select(Term, term_ID, elim, DB) %>% head(20) %>% arrange(DB, elim) %>% mutate(nlogp=-log10(elim)) -> xx
xx$Term = factor(xx$Term, levels=rev(xx$Term))
ggplot(xx) + 
  geom_col(aes(nlogp,Term,fill=DB),color='black' )+ 
  theme(legend.position = 'none') +
  theme_bw() + scale_fill_manual("ontology",values=c('#404040','grey','white')) +
  ggtitle("Terms enriched in genes mapped to 'not changing' peaks")



o[['K1']] %>% rename(term_ID=GO.ID) -> ok1

bp=(read.csv('gene_lists/K1.REVIGO/K1.BP.csv') %>% filter(eliminated == 0) %>% select(term_ID))[[1]]
cc=(read.csv('gene_lists/K1.REVIGO/K1.CC.csv') %>% filter(eliminated == 0) %>% select(term_ID))[[1]]
mf=(read.csv('gene_lists/K1.REVIGO/REVIGO.MF.csv') %>% filter(eliminated == 0) %>% select(term_ID))[[1]]

ok1 %>% filter(term_ID %in% c(bp,cc,mf)) %>% arrange(`Rank in elim`,elim) %>% select(Term, term_ID, elim, DB) %>% head(20) %>% arrange(DB, elim) %>% mutate(nlogp=-log10(elim)) -> xx
xx$Term = factor(xx$Term, levels=rev(xx$Term))
ggplot(xx) + 
  geom_col(aes(nlogp,Term,fill=DB),color='black' )+ 
  theme(legend.position = 'none') +
  theme_bw() + scale_fill_manual("ontology",values=c('#404040','grey','white')) +
  ggtitle("Terms enriched in genes mapped to embryo-high peaks")


o[['K2']] %>% rename(term_ID=GO.ID) -> ok2

bp=(read.csv('gene_lists/K2.REVIGO/K2.BP.csv') %>% filter(eliminated == 0) %>% select(term_ID))[[1]]
cc=(read.csv('gene_lists/K2.REVIGO/K2.CC.csv') %>% filter(eliminated == 0) %>% select(term_ID))[[1]]
mf=(read.csv('gene_lists/K2.REVIGO/K2.MF.csv') %>% filter(eliminated == 0) %>% select(term_ID))[[1]]

ok2 %>% filter(term_ID %in% c(bp,cc,mf)) %>% arrange(`Rank in elim`,elim) %>% select(Term, term_ID, elim, DB) %>% head(20) %>% arrange(DB, elim) %>% mutate(nlogp=-log10(elim)) -> xx
xx$Term = factor(xx$Term, levels=rev(xx$Term))
ggplot(xx) + 
  geom_col(aes(nlogp,Term,fill=DB),color='black' )+ 
  theme(legend.position = 'none') +
  theme_bw() + scale_fill_manual("ontology",values=c('#404040','grey','white')) +
  ggtitle("Terms enriched in genes mapped to larval-high peaks")

o[['K3']] %>% rename(term_ID=GO.ID) -> ok3

bp=(read.csv('gene_lists/K3.REVIGO/K3.BP.csv') %>% filter(eliminated == 0) %>% select(term_ID))[[1]]
cc=(read.csv('gene_lists/K3.REVIGO/K3.CC.csv') %>% filter(eliminated == 0) %>% select(term_ID))[[1]]
mf=(read.csv('gene_lists/K3.REVIGO/K3.MF.csv') %>% filter(eliminated == 0) %>% select(term_ID))[[1]]


ok3 %>% filter(term_ID %in% c(bp,cc,mf)) %>% arrange(`Rank in elim`,elim) %>% select(Term, term_ID, elim, DB) %>% head(20) %>% arrange(DB, elim) %>% mutate(nlogp=-log10(elim)) -> xx
xx$Term = factor(xx$Term, levels=rev(xx$Term))
ggplot(xx) + 
 geom_col(aes(nlogp,Term,fill=DB),color='black' ) + 
  theme(legend.position = 'none') +
  theme_bw() + scale_fill_manual("ontology",values=c('#404040','grey','white')) +
  ggtitle("Terms enriched in genes mapped to L3-high peaks")


o[['K4']] %>% rename(term_ID=GO.ID) -> ok4

bp=(read.csv('gene_lists/K4.REVIGO/K4.BP.csv') %>% filter(eliminated == 0) %>% select(term_ID))[[1]]
cc=(read.csv('gene_lists/K4.REVIGO/K4.CC.csv') %>% filter(eliminated == 0) %>% select(term_ID))[[1]]
mf=(read.csv('gene_lists/K4.REVIGO/K4.MF.csv') %>% filter(eliminated == 0) %>% select(term_ID))[[1]]

ok4 %>% filter(term_ID %in% c(bp,cc,mf)) %>% arrange(`Rank in elim`,elim) %>% select(Term, term_ID, elim, DB) %>% head(20) %>% arrange(DB, elim) %>% mutate(nlogp=-log10(elim)) -> xx

xx$Term = factor(xx$Term, levels=rev(xx$Term))
ggplot(xx) + 
 geom_col(aes(nlogp,Term,fill=DB),color='black' ) + 
  theme(legend.position = 'none') +
  theme_bw() + scale_fill_manual("ontology",values=c('#404040','grey','white')) +
  ggtitle("Terms enriched in genes mapped to Increasing peaks")

dev.off()
```
