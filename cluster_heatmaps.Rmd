---
title: "Clustering of modENCODE/Reinke ChIP-seq peaks"
author: "DC King - Onish lab"
date: "Fall 2020"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
options(repos = c(CRAN = "http://cran.rstudio.com"))

# checks for packages, run install if necessary 
source("scripts/check_for_install_deps.R",echo = F) 
library(pheatmap, quietly=T, warn.conflicts = F)
library(stringr, quietly=T, warn.conflicts = F)
library(reshape2, quietly=T, warn.conflicts = F)
library(ggplot2, quietly=T, warn.conflicts = F)
library(ggExtra, quietly=T, warn.conflicts = F)
library(RColorBrewer, quietly=T, warn.conflicts = F) # for pheatmap
library(GenomicRanges, quietly=T, warn.conflicts = F)
library(biomaRt, quietly=T, warn.conflicts = F)
library(ChIPpeakAnno, quietly=T, warn.conflicts = F)
library(topGO, quietly=T, warn.conflicts = F)
library(dplyr, quietly=T, warn.conflicts = F)
library(UpSetR, quietly=T, warn.conflicts = F)
library(knitr, quietly=T, warn.conflicts = F)
library(grid, quietly=T, warn.conflicts = F)
library(VennDiagram, quietly=T, warn.conflicts = F)
library(plyranges, quietly=T, warn.conflicts = F) # tidy the GRange datatypes

```

## Script version and versions

This repo is from ``bash git remote -v```. Using ``r R.version.string``.

```{bash repo version, echo=FALSE}

git remote -v
git log -n 1
git status -s | grep -v '^?'
git diff cluster_heatmaps.Rmd
```
## Process data

The source data is a BED file corresponding to the basewise UNION of LE, L1, and L3 IDR peak files, run through an aggregate function (mod'd javaGenomicToolkit) that calculates summary information for each of the above ranges.

The original IDR peaks are rescanned to determine the composition of each peak.

```{r get-data, echo=FALSE}
# IDR peaks

# narrowPeak is bedlike. Each line contains - 
# The comprehensive range of two overlapping peaks.
# The comprehensive peak summit.
# The summit and ranges of the individual peaks.
# Score information.
source('scripts/makeGRangesFromNarrowPeak.R') # this script retains the extra columns and drops unused ones
#L1_IDR = makeGRangesFromNarrowPeak('L1_1_L1_2.IDR_0.05.narrowPeak')
L1_IDR = makeGRangesFromNarrowPeak('redux/L1.narrowPeak')
#LE_IDR = makeGRangesFromNarrowPeak('LE_1_LE_2.IDR_0.05.narrowPeak')
LE_IDR = makeGRangesFromNarrowPeak('redux/LE.narrowPeak')
#L3_IDR = makeGRangesFromNarrowPeak('L3_1_L3_2.IDR_0.05.narrowPeak')
L3_IDR = makeGRangesFromNarrowPeak('redux/L3.narrowPeak')
# Union of all IDR output, with peak maxes assigned via my modification of javaGenomicsToolkit https://github.com/meekrob/java-genomics-toolkit
#df = read.table("allStagesUNION.IDR_0.05.sorted.bed_s.df", header=T, sep="\t")
df = read.table("redux/allStagesUnion.bed.df", header=T, sep="\t")
chroms <- Seqinfo(c('chrI', 'chrII', 'chrIII', 'chrIV', 'chrV', 'chrX', 'chrM'),
                    c(15072434, 15279421, 13783801, 17493829, 20924180, 17718942, 13794),
                    rep(FALSE,7),
                    rep("chr11",7))

dfG = makeGRangesFromDataFrame(df, 
                               keep.extra.columns = T, 
                               ignore.strand = T, 
                               seqinfo=chroms,
                               starts.in.df.are.0based = T)
# may be a warning about out-of-bound ranges. This might be generated by IDR or SPP procedures.
dfG = trim(dfG)

dfG$LE_IDR = FALSE
dfG$L1_IDR = FALSE
dfG$L3_IDR = FALSE
```
### Description of data

The total number of merged peaks is ``r length(dfG)``.
Now, map the IDR calls into the aggregate dataframe, showing the architecture of the union.

```{r manage-data, echo=FALSE}

#### Mark which IDR peaks contributed to the union
LE_verify = GenomicRanges::findOverlaps(LE_IDR, dfG, type="any")
L1_verify = GenomicRanges::findOverlaps(L1_IDR, dfG, type="any")
L3_verify = GenomicRanges::findOverlaps(L3_IDR, dfG, type="any")
dfG$LE_IDR[ to(LE_verify) ] <- TRUE
dfG$L1_IDR[ to(L1_verify) ] <- TRUE
dfG$L3_IDR[ to(L3_verify) ] <- TRUE

source('scripts/r_isect_union.R')
#dfG$summit_agreement = score_peak_summit_agreement(dfG, LE_IDR, L1_IDR, L3_IDR)$summit_agreement

# collect some variables 
IDR_sets = list(LE_IDR=LE_IDR,L1_IDR=L1_IDR,L3_IDR=L3_IDR,LE_verify=LE_verify,L1_verify=L1_verify,L3_verify=L3_verify)
rm(LE_IDR,L1_IDR,L3_IDR,LE_verify,L1_verify,L3_verify)

# Remove the unused javaGenomicsToolkit columns (min,mean,etc.), and cut out the filename portions
# df -> df_max
df %>% dplyr::select(starts_with('max')) %>%
  dplyr::rename(
    max_log_LE_1_minus_log_LE_input=max_06_SIGNAL.LE_1_minus_input.bw,  
         max_log_LE_2_minus_log_LE_input=max_06_SIGNAL.LE_2_minus_input.bw,
         max_log_L1_1_minus_log_L1_input=max_06_SIGNAL.L1_1_minus_input.bw, 
         max_log_L1_2_minus_log_L1_input=max_06_SIGNAL.L1_2_minus_input.bw, 
         max_log_L3_1_minus_log_L3_input=max_06_SIGNAL.L3_1_minus_input.bw, 
         max_log_L3_2_minus_log_L3_input=max_06_SIGNAL.L3_2_minus_input.bw 

         )  %>%
  dplyr::select( # to reorder them
    max_log_LE_1_minus_log_LE_input,
    max_log_LE_2_minus_log_LE_input,
    max_log_L1_1_minus_log_L1_input,
    max_log_L1_2_minus_log_L1_input,
    max_log_L3_1_minus_log_L3_input,
    max_log_L3_2_minus_log_L3_input
  ) -> df_max

# The same operation for Genomic Ranges metadata
# dfG -> dfG_max
dfG_metadata <- mcols(dfG)
dfG_metadata %>% as.data.frame() %>% dplyr::select(-starts_with('min'), -starts_with('mean'), -starts_with('N')) %>%
  dplyr::rename(
         L1_1=max_06_SIGNAL.L1_1_minus_input.bw, 
         L1_2=max_06_SIGNAL.L1_2_minus_input.bw, 
         L3_1=max_06_SIGNAL.L3_1_minus_input.bw, 
         L3_2=max_06_SIGNAL.L3_2_minus_input.bw, 
         LE_1=max_06_SIGNAL.LE_1_minus_input.bw,  
         LE_2=max_06_SIGNAL.LE_2_minus_input.bw) %>%
  dplyr::select( # to reorder them
    LE_1,
    LE_2,
    L1_1,
    L1_2,
    L3_1,
    L3_2,
    ends_with("IDR")
   # summit_agreement
  ) -> 
  dfG_metadata_max
# not changing the row count, can map back onto dfG
dfG_max = dfG
mcols(dfG_max) <- dfG_metadata_max


position_columns = c("chrom","chromStart","chromEnd","ID")
# make numeric, with 

df_max %>% as.matrix() -> data6d

df_max %>% dplyr::mutate(
  LE=(max_log_LE_1_minus_log_LE_input+max_log_LE_2_minus_log_LE_input)/2,
  L1=(max_log_L1_1_minus_log_L1_input+max_log_L1_2_minus_log_L1_input)/2,
  L3=(max_log_L3_1_minus_log_L3_input+max_log_L3_2_minus_log_L3_input)/2
  ) %>% dplyr::select(LE,L1,L3) -> data3d

nrow(data3d)
```
### Post-scaling of data

Now the quantitative data represents 3 timepoints, 2 replicates each. Each value is the input and read-depth normalized pileups (signal) computed per basepair. The maximum value within a peak is the value used. There are ``r nrow(data3d)`` peaks, (and therefore rows).

Next we want to filter the lesser 5% invariant rows, and then normalize the values by row.

```{R normalization, echo=FALSE}

# perform normalization on 3d
peaks3d_sd = apply(data3d, 1, sd)
peaks3d_mu = apply(data3d, 1, mean)
peaks3d_std = (data3d - peaks3d_mu) /  peaks3d_sd

# perform normalization on 6d (data)
peaks6d_sd = apply(data6d, 1, sd)
peaks6d_mu = apply(data6d, 1, mean)
# normalize by row
peaks6d_std = (data6d- peaks6d_mu) /  peaks6d_sd

# change filenames to shorter labels
colnames(peaks6d_std) <- c("LE_1", "LE_2", "L1_1", "L1_2", "L3_1","L3_2")

# changing versus not-changing
q.peaks6d_zeroed_nans_sd = function(q) { quantile(peaks6d_sd, q)}
q.peaks3d_zeroed_nans_sd = function(q) { quantile(peaks3d_sd, q)}

THRESHOLD = .05

# make the text conversions consistent
TXT_THRESHOLD = sprintf("%.3f", THRESHOLD)

# Enforce stdev-passing peaks and "all IDR" as part of the threshold
# w/reps
threshold6d_q = q.peaks6d_zeroed_nans_sd(THRESHOLD)
threshold6d_ix = peaks6d_sd > threshold6d_q
# to restrict to all IDR only
#threshold6d_ix = dfG$LE_IDR & dfG$L1_IDR & dfG$L3_IDR & threshold6d_ix
threshold6d_x = peaks6d_std[threshold6d_ix,]
# w/reps avg'd
threshold3d_q = q.peaks3d_zeroed_nans_sd(THRESHOLD)
threshold3d_ix = peaks3d_sd > threshold3d_q
# to restrict to all IDR only
#threshold3d_ix = dfG$LE_IDR & dfG$L1_IDR & dfG$L3_IDR & threshold3d_ix
threshold3d_x = peaks3d_std[threshold3d_ix,]

include6d_x = threshold6d_x
include3d_x = threshold3d_x

# clean up the environment some more
thresholded_data = list( w_reps = list(threshold6d_q=threshold6d_q,
                                       threshold6d_ix=threshold6d_ix,
                                       threshold6d_x=threshold6d_x,
                                       include6d_x=include6d_x),
                         reps_avd = list(threshold3d_q=threshold3d_q,
                                         threshold3d_ix=threshold3d_ix,
                                         threshold3d_x=threshold3d_x,
                                         include3d_x=include3d_x),
                         THRESHOLD=THRESHOLD,
                         TXT_THRESHOLD = sprintf("%.3f", THRESHOLD))

rm(threshold6d_q,threshold6d_ix,threshold6d_x,include6d_x,
   threshold3d_q,threshold3d_ix,threshold3d_x,include3d_x,
   THRESHOLD,TXT_THRESHOLD)
```

### Evaluate overlap between different stages in terms of the stages called in an overlapping location

Using the original IDR files, compare them to the all UNION'd file. 

```{r overlap plots, echo=FALSE}
LEL1L3=ifelse(as.matrix(mcols(dfG_max))[,c('LE_IDR','L1_IDR','L3_IDR')],1,0)

## Venn diagram
area1 = sum(LEL1L3[,1] == 1)
area2 = sum(LEL1L3[,2] == 1)
area3 = sum(LEL1L3[,3] == 1)

n23 = sum( LEL1L3[,2] == 1 & LEL1L3[,3] == 1)
n12 = sum(LEL1L3[,1] == 1 & LEL1L3[,2] == 1 )
n13 = sum(LEL1L3[,1] == 1  & LEL1L3[,3] == 1)

n123 = sum(LEL1L3[,1] == 1 & LEL1L3[,2] == 1 & LEL1L3[,3] == 1)

LE_purple = "#7570B3" # Chetwode blue
L1_green = "#1B9E77" # Elf green 
L3_orange = "#D95F02" # Tawny
Increasing_pink = "#E7298A" # Deep Cerise

grid.newpage()
# title <- textGrob("Peaks", y=unit(0.5,"npc") + 0.5*h, 
#                   vjust=0, gp=gpar(fontsize=20))
grid.draw(
  draw.triple.venn(
    area1, area2, area3, n12, n23, n13, n123,
    fill=c(LE_purple,L1_green,L3_orange), # reflects the colors used in clusters/categories
    category=c("LE","L1","L3")
    )
  )

pdf("Peak_overlap_Venn.pdf") 
grid.draw(
  draw.triple.venn(
    area1, area2, area3, n12, n23, n13, n123,
    fill=c(LE_purple,L1_green,L3_orange), # reflects the colors used in clusters/categories
    category=c("LE","L1","L3")
    )
  )
dev.off()


overlap = function(under, over,a=.5) {
    r1 <- strtoi(substr(under, 2, 3), base = 16)
    r2 <- strtoi(substr(over, 2, 3), base = 16)
    g1 <- strtoi(substr(under, 4, 5), base = 16)
    g2 <- strtoi(substr(over, 4, 5), base = 16)
    b1 <- strtoi(substr(under, 6, 7), base = 16)
    b2 <- strtoi(substr(over, 6, 7), base = 16)
    
    
    result <- rgb(a * r2 + (1 - a) * r1,
                  a * g2 + (1 - a) * g1,
                  a * b2 + (1 - a) * b1,
                  alpha = 255,
                  max=255)
    return(result)
}
LEL1_color = overlap(LE_purple,L1_green)
L1L3_color = overlap(L1_green,L3_orange)
LEL3_color = overlap(LE_purple,L3_orange)
all_color = overlap(overlap(LEL1_color, L1L3_color), LEL3_color)

# upset plot
upset(as.data.frame(LEL1L3),
      order.by = "degree", decreasing=F,
      queries=list(
        list(
          query=intersects,
          params=list("LE_IDR"),
          color=LE_purple,
          active=T
        ),
        list(
          query=intersects,
          params=list("L1_IDR"),
          color=L1_green,
          active=T
        ),
        list(
          query=intersects,
          params=list("L3_IDR"),
          color = L3_orange,
          active=T
        ),
        list(
          query=intersects,
          params=list("LE_IDR","L1_IDR"), 
          color = LEL1_color,
          active=T),
      list(
          query=intersects,
          params=list("LE_IDR","L3_IDR"), 
          color = LEL3_color,
          active=T),
      list(
          query=intersects,
          params=list("L1_IDR","L3_IDR"), 
          color = "#A0682A",
          active=T),
      list(
          query=intersects,
          params=list("LE_IDR","L1_IDR","L3_IDR"), 
          color = "#926134",
          active=T)
        )
)
# 
# cat("Datasets: threshold at:", thresholded_data$TXT_THRESHOLD,"\n")
# cat("include_x: reps not merged:", dim(thresholded_data$w_reps$include6d_x),"\n")
# cat("include3d_x: reps merged:", dim(thresholded_data$reps_avd$include3d_x),"\n")
```

### K-means clustering

Perform K-means on the peaks that vary throughout the timecourse.

```{r cluster, echo=FALSE}
attach(thresholded_data)
source('scripts/reorder_kmeans.R')
nclust=4

# scree
wss=0
for (i in 2:20) {
  wss[i] = kmeans(reps_avd$include3d_x, centers = i)$tot.withinss
  
}
plot(2:20,wss[2:20],type='b',xlab='number of clusters', ylab='total within groups sum-of-squares', main="Skree plot for cluster number")

label=paste(
  sprintf("kmeans clusters at std. dev. > %.3f,", 
          reps_avd$threshold3d_q), 
          "(excludes lower ", sprintf("%.1f%%)", 
          THRESHOLD*100))
clusters = list()

set.seed(31415)
pobj = pheatmap(reps_avd$include3d_x, kmeans=nclust, cluster_rows=F, cluster_cols = F, main=label)
clusters$kmeans_on3d_k4 = reorder_kmeans(pobj$kmeans)
k4_explained_variance = clusters$kmeans_on3d_k4$betweenss/clusters$kmeans_on3d_k4$totss

heatmap_color = colorRampPalette(rev(brewer.pal(n = 7, name ="RdYlBu")))(100)
pheatmap(reps_avd$include3d_x[order(clusters$kmeans_on3d_k4$cluster),], cluster_rows=F, cluster_cols=F, color=heatmap_color, show_rownames=F)

set.seed(31415)
clusters$kmeans_on3d_k6 = reorder_kmeans(kmeans(reps_avd$include3d_x,6))
k6_explained_variance = clusters$kmeans_on3d_k6$betweenss/clusters$kmeans_on3d_k6$totss


# trend plot with 4 clusters
clusters$k4_trends = clusters$kmeans_on3d_k4$centers
rownames(clusters$k4_trends) <- c("LE-specific", "Post embryonic", "L3-high","Increasing")

clusters$k4_trends_long = melt(clusters$k4_trends)
colnames(clusters$k4_trends_long) <- c("description", "stage", "center")

label=paste(sprintf("%d cluster trends at std. dev. > %.3f,", nrow(clusters$k4_trends), reps_avd$threshold3d_q), "(excludes lower ", sprintf("%.1f%%)", THRESHOLD*100))
figure_colors = scale_colour_manual(values=c("#7570B3","#1B9E77","#D95F02","#E7298A"))
print(
  ggplot(clusters$k4_trends_long, 
         aes(x=stage,y=center, 
             group=description,
             colour=description)) + 
    geom_line(size = 2) + 
    labs(title="Kmeans cluster centers (k=4)",
         subtitle=sprintf("%.1f%% variance explained",100*k4_explained_variance),
         y = "cluster center (Z)", 
         x = "developmental stage") + 
    figure_colors)

# for the figure, separate out the groups into a separate plot, lay them out vertically,
# and prevent the domain from expanding
print( # k4stacked.pdf, scrunch the "Plots" display in the right panel all the way down to real dimensions you expect in the 
       # Illustrator file.
    ggplot(clusters$k4_trends_long, 
           aes(x=stage,y=center, 
               group=description,
               colour=description)) + 
        geom_line(size = 2) + 
        labs(title="Kmeans cluster centers (k=4)", 
             y = "cluster center (Z)", 
             x = "developmental stage") + 
      figure_colors + facet_grid(description ~ .) +  
      theme(legend.position = "none",
            strip.text.y = element_blank(), # omit facet label
            aspect.ratio=1.4787/3,
            panel.spacing=unit(.7,"cm"),
            panel.background=element_rect(fill='white'),
            panel.grid.minor.y=element_line(colour='black',linetype = 'dashed',size=.5),
            panel.grid.major.y=element_line(colour='black',linetype = 'solid',size=.75), 
            panel.grid.major.x=element_line(colour='grey',linetype = 'solid',size=.5)) +
      scale_x_discrete(expand=rep(0,4)) + 
      scale_y_continuous(breaks = c(-1,0,1),
                         minor_breaks=c(-.5,.5)
                         )
)

# trend plot with 6 clusters
clusters$k6_trends = as.data.frame(clusters$kmeans_on3d_k6$centers)
clusters$k6_trends$label <- sprintf("%d (%d)", 1:6, clusters$kmeans_on3d_k6$size)

k6_trends_long = melt(clusters$k6_trends)
k6_trends_long$label = factor(k6_trends_long$label, levels = clusters$k6_trends$label)
colnames(k6_trends_long) <- c("cluster","stage","center")

figure_colors = scale_colour_manual(name="cluster Id (size)", 
                                      values=c("#7570B3", "#A6D854", "#1B9E77","#D95F02","#E7298A","#E7298A")
                                      )
print(
  ggplot(k6_trends_long, 
         aes(x=stage,y=center, 
             group=cluster,
             colour=cluster)) + 
    geom_line(size = 1.5) + 
    labs(title="Kmeans cluster centers (k=6)",
         subtitle=sprintf("%.1f%% variance explained",100*k6_explained_variance),
         y = "cluster center (Z)", 
         x = "developmental stage") + 
    figure_colors + 
    theme(panel.background=element_rect(fill='#E6E6E6'))
    
  )

source('scripts/kweights.R')
# The profiler points to rbind in the euclid/dist call as the main time sync.
# Maybe this can be avoided by pasting the cluster centers onto the data (a single call to rbind),
# then running dist() on the resulting table. The euclid function would then access the appropriate
# rows of the resultant output, called by weight_f(), which is applied over each center for each row
# of data, and summed inside row_func, which returns the reciprocal as the value of w[i][j].
clusters$k4weights = kweights(reps_avd$include3d_x, clusters$kmeans_on3d_k4$cluster, clusters$kmeans_on3d_k4$centers)
# laptop:
#    user  system elapsed 
#   17.295   0.227  18.562 
#clusters$k6weights = kweights(reps_avd$include3d_x, clusters$kmeans_on3d_k6$cluster, clusters$kmeans_on3d_k6$centers)
clusters$k6weights = rep(1,length(clusters$kmeans_on3d_k6$cluster))

# The standard heatmaps. See https://stackoverflow.com/questions/36852101/r-legend-title-or-units-when-using-pheatmap for 
# getting the data out manually.
pheatmap(reps_avd$include3d_x[order(clusters$kmeans_on3d_k4$cluster,-clusters$k4weights),], cluster_rows=F, cluster_cols=F, color=heatmap_color, show_rownames=F)
pheatmap(reps_avd$include3d_x[order(clusters$kmeans_on3d_k6$cluster,-clusters$k6weights),], cluster_rows=F, cluster_cols=F, color=heatmap_color, show_rownames=F)

if(F)
{
  pdf("fig2_heatmap.pdf",width=7, height=3)
pheatmap(t(reps_avd$include3d_x[order(clusters$kmeans_on3d_k4$cluster, -clusters$k4weights),]), cluster_rows=F, cluster_cols=F, color=heatmap_color, show_colnames=F)
dev.off()
}
# add clusters and weights to GenomicRanges object
dfG_max$k4cluster = 0
dfG_max$k6cluster = 0
dfG_max$k4weights = 0
dfG_max$k6weights = 0
dfG_max$k4cluster[reps_avd$threshold3d_ix] <- clusters$kmeans_on3d_k4$cluster
dfG_max$k4weights[reps_avd$threshold3d_ix] = clusters$k4weights
dfG_max$k6cluster[reps_avd$threshold3d_ix] <- clusters$kmeans_on3d_k6$cluster
dfG_max$k6weights[reps_avd$threshold3d_ix] = clusters$k6weights

```

### Prepare data structures to output bigBed files.

Custom tracks are served locally (but world-readable). The chunk currently also maps peaks to genes through the "scripts/getCodingGenes.R".

```{r format prepare BED, echo=FALSE}
dfG_max$LE_nonNormed = (dfG_max$LE_1 + dfG_max$LE_2)/2
dfG_max$L1_nonNormed = (dfG_max$L1_1 + dfG_max$L1_2)/2
dfG_max$L3_nonNormed = (dfG_max$L3_1 + dfG_max$L3_2)/2
dfG_max$LE_std = peaks3d_std[,1]
dfG_max$L1_std = peaks3d_std[,2]
dfG_max$L3_std = peaks3d_std[,3]

# if you do this, you can't rerun the chunk.
if (FALSE) {
  # drop the individual rep columns
  dfG_max$LE_1 = NULL
  dfG_max$LE_2 = NULL
  dfG_max$L1_1 = NULL
  dfG_max$L1_2 = NULL
  dfG_max$L3_1 = NULL
  dfG_max$L3_2 = NULL
}

float_precision_string = "%.3f"
peaksForBigBed = dfG_max
peaksForBigBed$LE_IDR = as.integer(dfG_max$LE_IDR)
peaksForBigBed$L1_IDR = as.integer(dfG_max$L1_IDR)
peaksForBigBed$L3_IDR = as.integer(dfG_max$L3_IDR)
peaksForBigBed$name = sprintf("ELT2peak%05d", 1:length(peaksForBigBed))
peaksForBigBed$k4weights = sprintf(float_precision_string, peaksForBigBed$k4weights)
peaksForBigBed$k4labels = c(
  "Not-changing or not IDR-passing",
  "LE-specific",
  "Post-embryonic",
  "L3-high",
  "Increasing"
)[peaksForBigBed$k4cluster + 1]
peaksForBigBed$k6weights = sprintf(float_precision_string, peaksForBigBed$k6weights)
peaksForBigBed$variance = apply(mcols(peaksForBigBed)[,c('LE_nonNormed','L1_nonNormed','L3_nonNormed')], 1, var)
peaksForBigBed$LE_nonNormed = sprintf(float_precision_string, peaksForBigBed$LE_nonNormed)
peaksForBigBed$L1_nonNormed = sprintf(float_precision_string, peaksForBigBed$L1_nonNormed)
peaksForBigBed$L3_nonNormed = sprintf(float_precision_string, peaksForBigBed$L3_nonNormed)
peaksForBigBed$LE_std = sprintf(float_precision_string, peaksForBigBed$LE_std)
peaksForBigBed$L1_std = sprintf(float_precision_string, peaksForBigBed$L1_std)
peaksForBigBed$L3_std = sprintf(float_precision_string, peaksForBigBed$L3_std)

source('scripts/getCodingGenes.R',echo=F)
system.time({annotatedPeaks = getCodingGenes(peaksForBigBed)})
attach(annotatedPeaks)
# this is now inaccurate after changing peaks (and their numbering)
#ra = read.table('data/genemapping.right.answers')
#cat("Inconsistent gene mappings:", sum(ap[ ra[[1]] ]$feature != ra[[3]]))
## See previous commits forspread sheet for spot-checks

mapping_breakdown = table(ap$insideFeature)
pie_labels = paste0(names(table(ap$insideFeature)), rep(" (",5), table(ap$insideFeature), rep(")",5))
pie(table(ap$insideFeature), labels=pie_labels, main="Gene features at or near ELT-2 occupied peaks", sub='The closest feature to a peak is mapped unless farther than 5KB.\n "insideFeature" means the peak completely encompasses the gene (might be a consequence of the merge).')

features_observed = table(ap$insideFeature)
# empirical data
if (file.exists('feature_mapping_empirical.tbl')) {
feature_table = readRDS("feature_mapping_empirical.tbl") %>% as_tibble() %>% dplyr::rename('unmapped ± 5Kb'='unmapped - 5Kb') %>% as.matrix()
ecdf_downstream = ecdf(feature_table[,'downstream'])
ecdf_includeFeature = ecdf(feature_table[,'includeFeature'])
ecdf_inside = ecdf(feature_table[,'inside'])
ecdf_overlapEnd = ecdf(feature_table[,'overlapEnd'])
ecdf_overlapStart = ecdf(feature_table[,'overlapStart'])
ecdf_unmapped = ecdf(feature_table[,'unmapped ± 5Kb'])

# empirical p-values of Obs < Emp
ecdf_includeFeature(features_observed['includeFeature'])
ecdf_overlapStart(features_observed['overlapStart'])
ecdf_overlapEnd(features_observed['overlapEnd'])
ecdf_downstream( features_observed['downstream'] )
ecdf_inside(features_observed['inside'])
ecdf_unmapped(features_observed['unmapped ± 5Kb'])

features_observed %>% melt() %>% dplyr::rename(feature=Var1,count=value) -> feat_obs_tbl

feature_tibble <-
  as_tibble(feature_table) %>% melt(
    measure.vars = 1:7,
    variable.name = "feature",
    value.name = "count"
  )
# arrange (relevel) in a 5' to 3' order, but put includeFeature all the way to the right
fiveToThree = levels(feature_tibble$feature)[c(7, 5, 3, 4, 1, 6, 2)]
feature_tibble %>% 
  mutate(feature = factor(feature, levels = fiveToThree)) -> refeature_tibble

ggplot(refeature_tibble, aes(x = count)) + 
  scale_x_continuous(name = "Frequency of feature mappings in randomized intervals", labels = scales::comma) +
  scale_y_continuous(name = "# of simulations (out of 9,000)", labels=scales::comma) +
  geom_histogram(binwidth = 10) + 
  facet_wrap( ~ feature) + 
  geom_vline(
       data = feat_obs_tbl,
       aes(xintercept = count),
       color = "red",
       size = .5) +
labs(title = expression(paste("Gene features at or near ELT-2 occupied peaks compared to randomizations across the genome")),
       caption = "Red line shows the frequency observed for the labelled feature in the ELT-2 occupied peaks")


ggplot(refeature_tibble, aes(x=feature,y=count)) + geom_boxplot() +geom_col(data = feat_obs_tbl,aes(x=feature,y=count),fill='red') + theme_classic()

melt(
  features_observed,
  measure.vars = 1:7,
  variable.name = "feature",
  value.name = "count"
) %>% as_tibble() %>% dplyr::rename(feature = Var1) %>% mutate(feature = factor(feature, levels = fiveToThree))

features_expected = colMeans(feature_table)
emp_chisq = function(n) { sum(((n-features_expected)^2)/features_expected)}
var_stat = apply(feature_table, 1, emp_chisq)
obs_var_stat = emp_chisq(features_observed)

ggplot(as_tibble(var_stat) %>% filter(value < 400), aes(x = value)) + 
  geom_rect(
    data=as_tibble(var_stat) %>% filter(value < 400),
    aes(
      xmin = quantile(value, prob = 0),
      xmax = quantile(value, prob = .99),
      ymin = 0,
      ymax = Inf
    ),
    fill = 'beige',
    alpha = .5
  ) +
  geom_histogram(
    bins = 30,
    fill = "white",
    color = "tan",
    alpha = 0.5
  ) + theme_classic() +
  labs(title = "Variability from empirical values",
      x = "Value of variability statistic", 
      y = "Number of permutations with given value",
      caption = "The shaded yellow area shows the lower 99% of\nstatistic values for the 9,000 permutations across the genome.\n7 extrema exhibited a statistic between 1000-1400.  The observed feature statistic is 2923; therefore, the empirical p-value is 0.")

ggplot(as_tibble(var_stat) %>% mutate(value = log(value)), aes(x = value)) + 
  geom_rect(
    data=as_tibble(var_stat) %>% mutate(value = log(value)),
    aes(
      xmin = quantile(value, prob = 0),
      xmax = quantile(value, prob = .999),
      ymin = 0,
      ymax = Inf
    ),
    fill = 'beige',
    alpha = .5
  ) +
  geom_histogram(
    bins = 30,
    fill = "white",
    color = "tan",
    alpha = 0.5
  ) + theme_classic() +
  geom_vline(aes(xintercept=log(obs_var_stat)),
       color = "red",
       size = .5) +
  labs(title = "Variability from empirical values",
      x = "log(value) of variability statistic", 
      y = "Number of permutations with given log(value)",
      caption = "The shaded yellow area shows the lower 99.9% of statistic values for the 9,000 \npermutations across the genome. 7 extrema yield a high variability statistic (log), \nranging between 7.37-7.42. However, the variability statistic for the ELT-2 occupied \npeaks is log(2923)=7.98 (red line), greater than observed in 9000 random permutations.\nTherefore, the empirical p-value is 0.")
}

peakSchema = "
table ELT2DynamicPeaks
\"ELT-2 Dynamic Peaks\"
(
string  chrom;		\"Reference sequence chromosome or scaffold\"
uint    chromStart;	\"Start position of feature on chromosome\"
uint    chromEnd;	\"End position of feature on chromosome\"
string  name;		\"Index of peak\"
string  WBID;   \"Wormbase ID\"
string mapping; \"How did it map to the gene?\"
uint  k4cluster;  \"Cluster assignment in kmeans = 4, 0 for not-changing\"
string  k4label; \"Description of the trend for cluster\"
string  k4weight;   \"Weight assigned to kmeans = 4 cluster assignment [0-1]\"
char[1] LE_IDR; \"0/1 IDR peak in Late embryo\"
char[1] L1_IDR; \"0/1 IDR peak in Stage 1 Larvae\"
char[1] L3_IDR; \"0/1 IDR peak in Stage 3 Larvae\"
)"
write(peakSchema, "peaks.as")




# make a dataframe that is in the same order as above
write.table(data.frame(as.character(seqnames(annotatedPeaks$ap)),
                       start(annotatedPeaks$ap),
                       end(annotatedPeaks$ap),
                       annotatedPeaks$ap$name,
                       annotatedPeaks$ap$feature,
                       annotatedPeaks$ap$insideFeature,
                       annotatedPeaks$ap$k4cluster,
                       annotatedPeaks$ap$k4labels,
                       annotatedPeaks$ap$k4weights,
                       annotatedPeaks$ap$LE_IDR,
                       annotatedPeaks$ap$L1_IDR,
                       annotatedPeaks$ap$L3_IDR#,
                       #annotatedPeaks$ap$summit_agreement
                    
                       ), "peaksForBigBed.bed",quote=F,row.names=F,col.names=F,sep="\t")
chrom.sizes = "chrV	20924180
chrX	17718942
chrIV	17493829
chrII	15279421
chrI	15072434
chrIII	13783801
chrM	13794"
write(chrom.sizes,"chrom.sizes")
```

### A BASH chunk, bedToBigBed

Run UCSC-user apps tools.

```{bash make bigBed, echo=FALSE}
# you must execute the above chunks first
# better figure out the PATH on your system
PATH=$PATH:/Users/david/bin/UCSC_userApps 
bedSort peaksForBigBed.bed peaksForBigBed.bed
bedToBigBed peaksForBigBed.bed chrom.sizes peaksForBigBed.bb -type=bed3+8 -tab -as=peaks.as -extraIndex=name
```

### Plot gene mapping stats.

Pie chart for the relative locations and counts of how the peaks mapped to genes.

```{r Get Coding Genes, echo=FALSE}
# annotatedPeaks assigned in previous chunk
attach(annotatedPeaks)
 # a pie chart with the breakdown of how the annotation happened
mapping_breakdown = table(ap$insideFeature)
breakdown = list(`upstream` = mapping_breakdown['upstream'] +
                              mapping_breakdown['overlapStart'],
                 `inside` = mapping_breakdown['inside'] + 
                            mapping_breakdown['includeFeature'],
                 `downstream` = mapping_breakdown['downstream'] + 
                                mapping_breakdown['overlapEnd'],
                 `unmapped` = mapping_breakdown['unmapped']
                 )

pie_labels = paste0(names(breakdown), rep(" (",4), unlist(breakdown), rep(")",4))
pie(unlist(breakdown), labels=pie_labels, main="Peaks mapping nearest to a gene", clockwise=T, init.angle=-90)

pdf("gene_mapping_pie.pdf")

pie_labels = paste0(names(breakdown), rep(" (",4), unlist(breakdown), rep(")",4))
pie(unlist(breakdown), labels=pie_labels, main="Peaks mapping nearest to a gene", clockwise=T, init.angle=-90)

dev.off()

# upset plot: identify set overlap by assigned value of k
clustersPerGene = table(ap$feature, ap$k4cluster)
wbid_rownames = rownames(clustersPerGene)
# some bool vectors
wbid_names_k0_bool = clustersPerGene[,'0'] > 0
wbid_names_k1_bool = clustersPerGene[,'1'] > 0
wbid_names_k2_bool = clustersPerGene[,'2'] > 0
wbid_names_k3_bool = clustersPerGene[,'3'] > 0
wbid_names_k4_bool = clustersPerGene[,'4'] > 0

wbid_clusters= list(k0=wbid_rownames[wbid_names_k0_bool],
                    k1=wbid_rownames[wbid_names_k1_bool],
                    k2=wbid_rownames[wbid_names_k2_bool],
                    k3=wbid_rownames[wbid_names_k3_bool], 
                    k4=wbid_rownames[wbid_names_k4_bool])

# Save lists of genes
for (wbk in names(wbid_clusters)) {
  print(length(wbid_clusters[[wbk]]))
  filename=sprintf("gene_lists/%s.Genes.txt",wbk)
  write.table(wbid_clusters[[wbk]], filename, quote=F, row.names = F, col.names = F)
}
write.table(unique(wbid_rownames), file="gene_lists/all.genes.txt",quote=F, row.names = F, col.names = F)
write.table(unique(wbid_rownames[!wbid_names_k0_bool]),file="gene_lists/all.dynamic.genes.txt",quote=F, row.names = F, col.names = F)

library(UpSetR);
wbid_clusters_fromlist = fromList(wbid_clusters) %>% rename("not_changing" = k0, Embryo=k1, Larval= k2, L3=k3, Increasing=k4)

upset(wbid_clusters_fromlist, 
      sets=rev(c("Embryo", "Larval", "L3", "Increasing")), 
      mainbar.y.label = "Geneset intersections", 
      sets.x.label="# of genes in cluster",
      set_size.show=T,
      group.by="degree",
      text.scale=1.5, 
      keep.order = T,
      query.legend = "top", 
      nintersects=NA, 
      order.by = "freq", decreasing=T,
            queries=list(
        list(
          query.name = "Embryo-only",
          query=intersects,
          params=list("Embryo"),
          color=LE_purple,
          active=T
        ),
        list(
          query.name = "Larval-only",
          query=intersects,
          params=list("Larval"),
          color=L1_green,
          active=T
        ),
        list(
          query.name = "L3-only",
          query=intersects,
          params=list("L3"),
          color = L3_orange,
          active=T
        ),
        list(
          query.name = "Increasing-only",
          query=intersects,
          params=list("Increasing"),
          color = Increasing_pink,
          active=T
        ),
        list(
          query=intersects,
          params=list("Increasing","L3"),
          color = overlap(Increasing_pink,L3_orange),
          active=T
        ),
        list(
          query=intersects,
          params=list("Larval","Increasing"),
          color = overlap(L1_green,Increasing_pink),
          active=T
        ),
        list(
          query=intersects,
          params=list("Larval","L3"),
          color = overlap(L1_green,L3_orange),
          active=T
        ),
        list(
          query=intersects,
          params=list("Larval","L3","Increasing"),
          color="darkgoldenrod",
          active=T
        )
        )
      )
        


# breakdown of genes with multiple peaks
clustersPerGene_rowSums = rowSums(clustersPerGene)
multiple_peaks = clustersPerGene_rowSums > 1
sum(multiple_peaks) # 2280
breakdown=table(clustersPerGene_rowSums)
bp=barplot(table(clustersPerGene_rowSums), xlab="number of peaks mapped to a gene", ylab="number of genes", main="Genes tend to have a single peak mapped to them")
i=1; y=breakdown[i]; text(bp[i,1],y - strheight(y,srt=90)*1.9,srt=90, labels = y)
for (i in 2:10) { y=breakdown[i]; text(bp[i,1],y + strheight(y,srt=90)*1.66,srt=90, labels = y) }

# to create this plot in a separate file:
if (FALSE)
{
  pdf(file="fig1.pdf")
  print(ggplot(trends_ordered_long, aes(x=stage,y=center, group=description,colour=description )) + geom_line(size = 1.5) + labs(title=label, y = "cluster center (Z)", x = "developmental stage"))  
  dev.off()
}
```

### GO data and processing functions

Data is from paramart, the functions are necessary to make the topGO analysis easier to repeat across the clusters.

```{r GO Functions, echo=FALSE}
# get the annotations from PARASITE
if (! "paramart" %in% ls()) {
  system.time({paramart <- useMart("parasite_mart", dataset = "wbps_gene", host = "https://parasite.wormbase.org", port = 443)})}
if (! "WORMGO" %in% ls()) {
  # go to https://parasite.wormbase.org/biomart/martview/ to figure out the values to use for this
  system.time({WORMGO = biomaRt::getBM(
    mart = paramart,
    filter = "species_id_1010",
    value = "caelegprjna13758",
    attributes = c(
      "wbps_gene_id",
      "external_gene_id",
      "go_accession",
      "go_name_1006",
      "go_linkage_type"
    )
  )}) 
}



# create an object where you can access all the GO terms that are assigned to a specific gene
geneID2GO <- by(WORMGO$go_accession, WORMGO$wbps_gene_id, function(x) as.character(x))

GOSummary<- function(GOdata, topNodes = 200) {
  
  resultClassic <- runTest(GOdata, algorithm = "classic", statistic = "fisher")
  resultElim <- runTest(GOdata, algorithm = "weight01", statistic = "fisher")
  
  GenTable(
    object=GOdata, 
    classicFisher = resultClassic,
    elim=resultElim,    
    orderBy="elim",
    topNodes = topNodes
  ) -> tab
  # not sure where the conversion to char is happening. convert back
  tab$classicFisher = as.numeric(tab$classicFisher)
  tab$elim = as.numeric(tab$elim)
  return(tab)
}


mkGO = function(foreground_genes, background_genes) {
  # create a TRUE/FALSE list the size of background genes, TRUE if in foreground
  geneList = factor(as.integer(background_genes %in% foreground_genes))
  names(geneList) = background_genes
  BP.go = new("topGOdata", ontology='BP'
              , allGenes = geneList
              , annot = annFUN.gene2GO
              , gene2GO = geneID2GO)
  MF.go = new("topGOdata", ontology='MF'
              , allGenes = geneList
              , annot = annFUN.gene2GO
              , gene2GO = geneID2GO)
  CC.go = new("topGOdata", ontology='CC'
              , allGenes = geneList
              , annot = annFUN.gene2GO
              , gene2GO = geneID2GO)
  list(BP=BP.go,CC=CC.go,MF=MF.go)
}
```

### Perform GO-term enrichment analyses

Run the topGO analyses using the above functions. 

``` {r GO term analysis, include=FALSE}
attach(annotatedPeaks)

unique.clust_0_wbid = unique((annotatedPeaks$ap %>% filter(k4cluster == 0))$feature)
unique.clust_1_wbid = unique((annotatedPeaks$ap %>% filter(k4cluster == 1))$feature)
unique.clust_2_wbid = unique((annotatedPeaks$ap %>% filter(k4cluster == 2))$feature)
unique.clust_3_wbid = unique((annotatedPeaks$ap %>% filter(k4cluster == 3))$feature)
unique.clust_4_wbid = unique((annotatedPeaks$ap %>% filter(k4cluster == 4))$feature)

all.genes <- unique(as.character(WORMGO$wbps_gene_id))
unique.ap.wbid = unique(annotatedPeaks$ap$feature)
all.GO = mkGO(unique.ap.wbid, all.genes)
K0.GO = mkGO(unique.clust_0_wbid, unique.ap.wbid)
K1.GO = mkGO(unique.clust_1_wbid, unique.ap.wbid)
K2.GO = mkGO(unique.clust_2_wbid, unique.ap.wbid)
K3.GO = mkGO(unique.clust_3_wbid, unique.ap.wbid)
K4.GO = mkGO(unique.clust_4_wbid, unique.ap.wbid)
l = list(K0=K0.GO,K1=K1.GO,K2=K2.GO,K3=K3.GO,K4=K4.GO)

o = list()
for (dataset.name in names(l)) {
  print(dataset.name)
  dataset = l[[dataset.name]]
  BP.tab = GOSummary(dataset$BP) %>% filter(elim < .05) %>% arrange(elim) %>% mutate(DB="BP")
  CC.tab = GOSummary(dataset$CC) %>% filter(elim < .05) %>% arrange(elim) %>% mutate(DB="CC")
  MF.tab = GOSummary(dataset$MF) %>% filter(elim < .05) %>% arrange(elim) %>% mutate(DB="MF")
  o[dataset.name] = list(rbind(BP.tab, CC.tab, MF.tab))
}
```

### Output GO term enrichment results. Also, write files to paste into Revigo analysis, which collapses terms.

Paste output two-column files (GO-term p-like-value) into the form at. http://revigo.irb.hr/index.jsp


``` {r GO output, echo=FALSE}


kable(o[['K1']] %>% select(-classicFisher,-'Rank in elim') %>% rename(pval=elim) %>% arrange(pval) %>% head(20), caption="Embryo cluster versus whole dataset")

kable(o[['K2']] %>% select(-classicFisher,-'Rank in elim') %>% rename(pval=elim) %>% arrange(pval) %>% head(20), caption="Larval cluster versus whole dataset")

kable(o[['K3']] %>% select(-classicFisher,-'Rank in elim') %>% rename(pval=elim) %>% arrange(pval) %>% head(20), caption="L3 cluster versus whole dataset")

kable(o[['K4']] %>% select(-classicFisher,-'Rank in elim') %>% rename(pval=elim) %>% arrange(pval) %>% head(20),
      caption="Increasing cluster versus whole dataset")

write.table(o$K0[,c(1,8)], "gene_lists/K0.REVIGO/K0.forREVIGO.txt",quote=F,col.names=F,row.names=F)
write.table(o$K1[,c(1,8)], "gene_lists/K1.REVIGO/K1.forREVIGO.txt",quote=F,col.names=F,row.names=F)
write.table(o$K2[,c(1,8)], "gene_lists/K2.REVIGO/K2.forREVIGO.txt",quote=F,col.names=F,row.names=F)
write.table(o$K3[,c(1,8)], "gene_lists/K3.REVIGO/K3.forREVIGO.txt",quote=F,col.names=F,row.names=F)
write.table(o$K4[,c(1,8)], "gene_lists/K4.REVIGO/K4.forREVIGO.txt",quote=F,col.names=F,row.names=F)

o[['K2']] %>% rename(term_ID=GO.ID) -> ok2
larv.revigo.bp = read.csv('freeze_1/K2.REVIGO.BP.csv')
ok2 %>% inner_join(larv.revigo.bp, by = 'term_ID') %>% select(-plot_X, -plot_Y, -plot_size) -> jok2
rownames(jok2) <- jok2$term_ID
```
