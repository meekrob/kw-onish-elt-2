---
title: "Clustering of modENCODE/Reinke ChIP-seq peaks"
author: "DC King - Onish lab"
date: "Spring 2019"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#knitr::opts_chunk$set(root.dir='~/work/onish_ChIP_R_Analysis')
knitr::include_graphics
options(repos = c(CRAN = "http://cran.rstudio.com"))
if(!requireNamespace("ggExtra")) {
  install.packages("ggExtra");
}
```

## Script version
```{bash version, echo=FALSE}
#cd ~/work/
git remote -v
git log -n 1
git status -s
```

## R version, libraries and scripts
```{r import}
R.version
library(pheatmap)
library(stringr)
library(reshape2)
library(ggplot2)
library(ggExtra)
library(RColorBrewer) # for pheatmap
library(GenomicRanges)
library(biomaRt)
library(ChIPpeakAnno)
library(topGO)

source('scripts/makeGRangesFromNarrowPeak.R')
```

## Process data
```{r get-data}
getwd()
# actual IDR results
L1_IDR = makeGRangesFromNarrowPeak('L1_1_L1_2.IDR_0.05.narrowPeak')
LE_IDR = makeGRangesFromNarrowPeak('LE_1_LE_2.IDR_0.05.narrowPeak')
L3_IDR = makeGRangesFromNarrowPeak('L3_1_L3_2.IDR_0.05.narrowPeak')
# merged results that have the peak maxes assigned via my modification of javaGenomicsToolkit
df = read.table("allStagesUNION.IDR_0.05.sorted.bed_s.df", header=T, sep="\t")
# need a GRanges object here 
dfG = makeGRangesFromDataFrame(df, keep.extra.columns = T, ignore.strand = T, starts.in.df.are.0based = T)

#### Re-map stage-specific peaks onto the big dataframe
dfG$LE_IDR = rep(FALSE, length(dfG))
dfG$L1_IDR = rep(FALSE, length(dfG))
dfG$L3_IDR = rep(FALSE, length(dfG))

LE_verify = GenomicRanges::findOverlaps(LE_IDR, dfG, type="any")
L1_verify = GenomicRanges::findOverlaps(L1_IDR, dfG, type="any")
L3_verify = GenomicRanges::findOverlaps(L3_IDR, dfG, type="any")

dfG$LE_IDR[ to(LE_verify) ] <- T
dfG$L1_IDR[ to(L1_verify) ] <- T
dfG$L3_IDR[ to(L3_verify) ] <- T
#### heh eh ehhe e


# dataframe
all_max_col_ix = which(! is.na(str_match(colnames(df),"max")))
df_max = df[,all_max_col_ix]
# GRanges with IDR cols
dfG_max_ix = which(! is.na(str_match(colnames(mcols(dfG)),"max")))
dfG_max = dfG[,c(dfG_max_ix,26:28)]

colnames(df_max)<-c("max_log_L1_1_minus_log_L1_input", "max_log_L1_2_minus_log_L1_input", "max_log_L3_1_minus_log_L3_input", "max_log_L3_2_minus_log_L3_input", "max_log_LE_1_minus_log_LE_input",  "max_log_LE_2_minus_log_LE_input")
colnames_in_stage_order = colnames(df_max)[c(5,6,1:4)]
position_columns = c("chrom","chromStart","chromEnd","ID")
# make numeric, with 
data = as.matrix(df_max[,colnames_in_stage_order])
# perform normalization
peaks_sd = apply(data, 1, sd)
peaks_mu = apply(data, 1, mean)
# normalize by row
row_scaled_x = (data - peaks_mu) /  peaks_sd

# change filenames to shorter labels
colnames(row_scaled_x) <- c("LE_1", "LE_2", "L1_1", "L1_2", "L3_1","L3_2")

# changing versus not-changing
q.peaks_zeroed_nans_sd = function(q) { quantile(peaks_sd, q)}

THRESHOLD = .05
THRESHOLD = .01
# make the text conversions consistent
TXT_THRESHOLD = sprintf("%.3f", THRESHOLD)
threshold_q = q.peaks_zeroed_nans_sd(THRESHOLD)
threshold_ix = peaks_sd > threshold_q
threshold_x = row_scaled_x[ threshold_ix,]

# steady class
steady_set_means = colMeans(row_scaled_x[ !threshold_ix, ])
steady_set_means = cbind(steady_set_means[1:2],steady_set_means[3:4],steady_set_means[5:6])
colnames(steady_set_means) <- c('LE','L1','L3')
rownames(steady_set_means) <- c('rep1','rep2')
steady_set_means = colMeans(steady_set_means)

# "excluded" means "constant during development", and needs an additional constraint of having IDR at all points
# the peakfiles retain the component peaks from replicates, but the comprehensive range is used
called_in_all = dfG$LE_IDR & dfG$L1_IDR & dfG$L3_IDR
threshold_ix_idr = !threshold_ix & called_in_all
two_of_three_idr = (dfG$LE_IDR & dfG$L1_IDR) | (dfG$LE_IDR & dfG$L3_IDR) | (dfG$L1_IDR & dfG$L3_IDR)
called_in_two_or_three_not_changing = dfG[! threshold_ix & two_of_three_idr]
exclude_ix = ! threshold_ix & called_in_all
include_ix = ! exclude_ix

include_x = row_scaled_x[ include_ix,]

nclust=4
set.seed(31415)
label=paste(sprintf("kmeans clusters at std. dev. > %.3f,", threshold_q), "(excludes lower ", sprintf("%.1f%%)", THRESHOLD*100))
pobj = pheatmap(include_x, kmeans=nclust, cluster_rows=F, cluster_cols = F, main=label)
kclusters = pobj$kmeans$cluster

### reorganize based on 4 meaningful trends
LEs = c( steady_set_means['LE'], apply(pobj$kmeans$centers[,1:2],1, mean)) #pobj$kmeans$centers[,1:2] 
L1s = c( steady_set_means['L1'], apply(pobj$kmeans$centers[,3:4],1, mean)) #pobj$kmeans$centers[,3:4] # 
L3s = c( steady_set_means['L3'], apply(pobj$kmeans$centers[,5:6],1, mean)) #pobj$kmeans$centers[,5:6] # 
names(LEs) <- 0:4
names(L1s) <- 0:4
names(L3s) <- 0:4
#sorted_k_order = order(LEs,L1s,L3s,decreasing=TRUE)
#trend_labels = c("LE_specific", "Post_embryonic", "Dev_increasing",  "L3_specific")
#k_remapping = data.frame(old=sorted_k_order,new=1:nclust,trend_label=trend_labels)

kremap = data.frame( `k`= 1:4, 
                     #`class`= 4:1, 
                     `class`= c(3,2,1,4), 
                     #`class_roman`=c('IV','III','II','I'), 
                     `class_roman`=c('III','II','I','IV'), 
                     `label`= c('Dev_increasing','Larval','Embryonic','L3_high'))


trends = cbind(LE=LEs,L1=L1s,L3=L3s)
# try using the slope of the dev-trends as a consistent way to order the LE,L1,L3 patterns
slopes = c( 
  lm(trends[1,] ~ k)$coef[2],
  lm(trends[2,] ~ k)$coef[2],
  lm(trends[3,] ~ k)$coef[2],
  lm(trends[4,] ~ k)$coef[2],
  lm(trends[5,] ~ k)$coef[2] )
trends_ordered = trends[order(slopes),]

# make a trend signature '+--' for LE-specific, etc.
plus_minus_symbols = as.data.frame(ifelse(trends > 0, '+', '-'))
trend_symbols = do.call(paste, c(plus_minus_symbols, sep=''))
# Sorting on the trend line seems to consistently yield the following order
rownames(trends_ordered) <- c("LE-specific", "Not changing", "Post embryonic", "L3-high","Increasing")

trends_ordered_long = melt(trends_ordered)
colnames(trends_ordered_long) <- c("description", "stage", "center")

label=paste(sprintf("Cluster trends at std. dev. > %.3f,", threshold_q), "(excludes lower ", sprintf("%.1f%%)", THRESHOLD*100))
figure_colors = scale_colour_manual(values=c("#7570B3","#666666","#1B9E77","#D95F02","#E7298A"))
print(ggplot(trends_ordered_long, aes(x=stage,y=center, group=description,colour=description )) + geom_line(size = 1.5) + labs(title=label, y = "cluster center (Z)", x = "developmental stage") + figure_colors)

## apply the new numbering to the data
reassigned_ks = kclusters
for (i in 1:4) {
 reassigned_ks = replace( reassigned_ks, kclusters == i, kremap[i, 'class'])
}


# prepare non-normalized output
# df colnames differ from manual ones on line 44
included_set = df[include_ix,c(position_columns, str_c(colnames_in_stage_order, "_z.bw"))]
included_set$class = reassigned_ks
split_non_normalized=split(included_set, included_set$class)



# Write a file for each class
# for (k_i in names(split_non_normalized)) { 
#   k_subset = split_non_normalized[[k_i]]
#   trend_name = sorted_k_remapping[as.numeric(k_i), 'trend_label']
#   kcluster_filename = paste("allStagesUNION_max_sd_", TXT_THRESHOLD, "_", trend_name, ".bedlike", sep="")
#   print(kcluster_filename)
#   write.table(k_subset, kcluster_filename, quote=F, sep="\t", row.names=F)
# }
korder = order(reassigned_ks, decreasing=F)

# colorMap, needed to state explictly to agree with Deeptools plots
color = colorRampPalette(rev(brewer.pal(n = 7, name ="RdYlBu")))(100)
label=paste(sprintf("Clustered peaks, selecting std. dev. > %.3f,", threshold_q), "(excludes lower ", sprintf("%.1f%%)", THRESHOLD*100))
pheatmap(include_x[korder,], cluster_rows=F, cluster_cols=F, color=color, show_rownames=F, main=label)

### The following is the actual plot for the heatmap figure. I rescale the values of k and add them as a column in the
### heatmap so that the different rows are easier to separate in Illustrator.

# combine replicates to just get a single value per stage per peak
LE = (include_x[,'LE_1'] + include_x[,'LE_2'])/2
L1 = (include_x[,'L1_1'] + include_x[,'L1_2'])/2
L3 = (include_x[,'L3_1'] + include_x[,'L3_2'])/2
# make a value representing only the cluster
klabel = rep(-2, length(LE))
klabel[kclusters == 2] <-  -1
klabel[kclusters == 3] <-  1
klabel[kclusters == 4] <-  2

combined_x = data.frame(LE,L1,L3,k=klabel)
label="10,270 ELT-2 Occupied Peaks cluster by developmental change"
pheatmap(combined_x[korder,], cluster_rows=F, cluster_cols=F, color=color, show_rownames=F, main=label)

## recoup the original file, the normalized data, and the cluster assignment
# Going to add 7 columns: the normalized value for each stage (times 2 reps) plus the 
# cluster assignment

# normalized data
all_nan_rows = apply(df_max, 1, function(x) { all(!is.finite(x))}); # this vector is now all FALSE, but needed
                                                                    # for downstream formulas
norm_LE_1 = rep(NA, nrow(df)); norm_LE_1[!all_nan_rows] = row_scaled_x[,1]
norm_LE_2 = rep(NA, nrow(df)); norm_LE_2[!all_nan_rows] = row_scaled_x[,2]
norm_L1_1 = rep(NA, nrow(df)); norm_L1_1[!all_nan_rows] = row_scaled_x[,3]
norm_L1_2 = rep(NA, nrow(df)); norm_L1_2[!all_nan_rows] = row_scaled_x[,4]
norm_L3_1 = rep(NA, nrow(df)); norm_L3_1[!all_nan_rows] = row_scaled_x[,5]
norm_L3_2 = rep(NA, nrow(df)); norm_L3_2[!all_nan_rows] = row_scaled_x[,6]

# kmeans cluster assignment
vec1 = rep(NA, nrow(row_scaled_x))
vec1[threshold_ix] = reassigned_ks
kclust_mapping = rep(NA, nrow(df))
kclust_mapping[! all_nan_rows] = vec1

# sd and mean
sd_mapping = rep(NA, nrow(df))
sd_mapping[!all_nan_rows] = peaks_sd
mean_mapping = rep(NA, nrow(df))
mean_mapping[!all_nan_rows] = peaks_mu
ecdf_sd = ecdf(peaks_sd)

# peaks_quantile: this row is changing more (via sd) than peaks_quantile fraction of the dataset
peaks_quantile = rep(NA, nrow(df))
peaks_quantile[!all_nan_rows] = ecdf_sd(peaks_sd)
# combine new columns
new_df = data.frame(norm_LE_1,norm_LE_2,norm_L1_1,norm_L1_2,norm_L3_1,norm_L3_2,mean_mapping, sd_mapping, peaks_quantile,kclust_mapping)

# paste new columns onto original file
big_df = cbind(df, new_df)
big_df$kclust_mapping[is.na(big_df$kclust_mapping)] <- 0
# add the comment char to the first column
colnames(big_df) <- c("#chrom", colnames(big_df)[2:38])

# switch from DF to GRanges object
peaks = makeGRangesFromDataFrame(big_df, keep.extra.columns = T, starts.in.df.are.0based=T, seqnames.field = '#chrom')
seqinfo(peaks) <- Seqinfo(c('chrI', 'chrII', 'chrIII', 'chrIV', 'chrV', 'chrX'), 
                    c(15072434, 15279421, 13783801, 17493829, 20924180, 17718942), 
                    c(FALSE, FALSE, FALSE, FALSE, FALSE, FALSE), 
                    c("ce11", "ce11", "ce11", "ce11", "ce11", "ce11"))

# retain IDR calls by stage
peaks$LE_IDR = dfG$LE_IDR
peaks$L1_IDR = dfG$L1_IDR
peaks$L3_IDR = dfG$L3_IDR
source('scripts/getCodingGenes.R',echo=T)
# Defines:
#  all_CDS_genes - GRanges object of all CDS genes, non-MT
#  ap - annotatedPeaks
#  ap.wbid - only the WB IDs 
#  unique.wbid - unique WB IDs
#  ap_0 - annotatedPeaks k0
#  ap_1 - annotatedPeaks k1
#  ap_2 - annotatedPeaks k2
#  ap_3 - annotatedPeaks k3
#  ap_4 - annotatedPeaks k4

# upset plot: identify set overlap by assigned value of k
clustersPerGene = table(ap$feature, ap$kclust_mapping)
wbid_rownames = rownames(clustersPerGene)
# some bool vectors
wbid_names_k0_bool = clustersPerGene[,'0'] > 0
wbid_names_k1_bool = clustersPerGene[,'1'] > 0
wbid_names_k2_bool = clustersPerGene[,'2'] > 0
wbid_names_k3_bool = clustersPerGene[,'3'] > 0
wbid_names_k4_bool = clustersPerGene[,'4'] > 0

wbid_clusters= list(k0=wbid_rownames[wbid_names_k0_bool],
                    k1=wbid_rownames[wbid_names_k1_bool],
                    k2=wbid_rownames[wbid_names_k2_bool],
                    k3=wbid_rownames[wbid_names_k3_bool], 
                    k4=wbid_rownames[wbid_names_k4_bool])

library(UpSetR);
wbid_clusters_fromlist = fromList(wbid_clusters)

upset(wbid_clusters_fromlist, sets=rev(c("k1", "k2", "k3", "k4","k0")), mainbar.y.label = "Geneset intersections", sets.x.label="# of genes in cluster", set_size.show=T,group.by="degree",text.scale=1.5,keep.order = T,query.legend = "top", nintersects=100, order.by = "degree", decreasing=F)

# breakdown of genes with multiple peaks
clustersPerGene_rowSums = rowSums(clustersPerGene)
multiple_peaks = clustersPerGene_rowSums > 1
sum(multiple_peaks) # 2158
breakdown=table(clustersPerGene_rowSums)
bp=barplot(table(clustersPerGene_rowSums), xlab="number of peaks mapped to a gene", ylab="number of genes", main="Genes tend to have a single peak mapped to them")
i=1; y=breakdown[i]; text(bp[i,1],y - strheight(y,srt=90)*1.9,srt=90, labels = y)
for (i in 2:10) { y=breakdown[i]; text(bp[i,1],y + strheight(y,srt=90)*1.66,srt=90, labels = y) }

# to create this plot in a separate file:
if (FALSE)
{
  pdf(file="fig1.pdf")
  print(ggplot(trends_ordered_long, aes(x=stage,y=center, group=description,colour=description )) + geom_line(size = 1.5) + labs(title=label, y = "cluster center (Z)", x = "developmental stage"))  
  dev.off()
}
# see previous commits for attempts to characterize the cluster patterns
```

``` {r GO term analysis}
# get the annotations from PARASITE
if (! "paramart" %in% ls()) {
  paramart <- useMart("parasite_mart", dataset = "wbps_gene", host = "https://parasite.wormbase.org", port = 443)}
if (! "WORMGO" %in% ls()) {
  # go to https://parasite.wormbase.org/biomart/martview/ to figure out the values to use for this
  WORMGO=biomaRt::getBM(mart = paramart, filter="species_id_1010", value="caelegprjna13758",
       attributes = c( "wbps_gene_id", 
            "external_gene_id", 
            "go_accession", 
            "go_name_1006", 
            "go_linkage_type")) 
}

# create an object where you can access all the GO terms that are assigned to a specific gene
geneID2GO <- by(WORMGO$go_accession, WORMGO$wbps_gene_id, function(x) as.character(x))


# All possible genes
all.genes <- unique(as.character(WORMGO$wbps_gene_id))
geneList = factor(as.integer(all.genes %in% ap.wbid))
names(geneList) = all.genes

BP.go = new("topGOdata", ontology='BP'
, allGenes = geneList
, annot = annFUN.gene2GO
, gene2GO = geneID2GO)

MF.go = new("topGOdata", ontology='MF'
, allGenes = geneList
, annot = annFUN.gene2GO
, gene2GO = geneID2GO)

CC.go = new("topGOdata", ontology='CC'
, allGenes = geneList
, annot = annFUN.gene2GO
, gene2GO = geneID2GO)

GOSummary<- function(GOdata) {
  test.stat <- new("classicCount", testStatistic = GOFisherTest, name = "Fisher test")
  resultFis <- getSigGroups(GOdata, test.stat)
  test.stat <- new("classicScore", testStatistic = GOKSTest, name = "KS tests")
  resultKS <- getSigGroups(GOdata, test.stat)
  test.stat <- new("elimCount", testStatistic = GOFisherTest, name = "Fisher test",cutOff = 0.01)
  resultElim <- getSigGroups(GOdata, test.stat)
  test.stat <- new("weightCount", testStatistic = GOFisherTest, name = "Fisher test", sigRatio = "ratio")
  resultWeight <- getSigGroups(GOdata, test.stat)
  l <- list(classic = resultFis, KS = resultKS, elim = resultElim,weight = resultWeight)
  return(GenTable(object=GOdata, weight=l$weight, classic=l$classic, elim=l$elim, KS=l$KS, orderBy="weight",ranksOf = "classic", topNodes = 50))
}

## algorithm weight01 performs a traversal of the DAG 
# BP.results.01f = runTest(BP.go, algorithm = "weight01", statistic="fisher")
# peakset.BP.results.tab <- GenTable(object = BP.go, elimFisher = BP.results.01f)
# showSigOfNodes(BP.go, score(BP.results.01f),useInfo = 'all' ,firstSigNodes = 10)
# 
# MF.go = new("topGOdata", ontology='MF'
# , allGenes = geneList
# , annot = annFUN.gene2GO
# , gene2GO = geneID2GO)
# GOdata=MF.go
# MF.results <- runTest(MF.go, algorithm = "weight01", statistic = "fisher")
# MF.results.tab <- GenTable(object = MF.go, elimFisher = MF.results)
# 
# 
# CC.go = new("topGOdata", ontology='CC'
# , allGenes = geneList
# , annot = annFUN.gene2GO
# , gene2GO = geneID2GO)
# GOdata = CC.go
# CC.results <- runTest(CC.go, algorithm = "weight01", statistic = "fisher")
# CC.results.tab <- GenTable(object = CC.go, elimFisher = CC.results, topNodes=20)

# Sub clusters vs all peaks

#0
unique.clust_0_wbid = unique(ap_0$feature);
geneList = factor(as.integer(unique.ap.wbid %in% unique.clust_0_wbid))
names(geneList) = unique.ap.wbid
BP.go = new("topGOdata", ontology='BP'
, allGenes = geneList
, annot = annFUN.gene2GO
, gene2GO = geneID2GO)

#BP.results.01f = runTest(BP.go, algorithm = "weight01", statistic="fisher")
#BP.results.k0.tab <- GenTable(object = BP.go, elimFisher = BP.results.01f, topNodes=20)
K0_allBPRes = GOSummary(BP.go)

#1
unique.clust_1_wbid = unique(ap_1$feature);
geneList = factor(as.integer(unique.ap.wbid %in% unique.clust_1_wbid))
names(geneList) = unique.ap.wbid
BP.go = new("topGOdata", ontology='BP'
, allGenes = geneList
, annot = annFUN.gene2GO
, gene2GO = geneID2GO)

# algo weight01 performs a conditional traversal of the DAG
#BP.results.01f = runTest(BP.go, algorithm = "weight01", statistic="fisher")
#BP.results.k1.tab <- GenTable(object = BP.go, elimFisher = BP.results.01f, topNodes=20)
K1_allBPRes = GOSummary(BP.go)

#2
unique.clust_2_wbid = unique(ap_2$feature);
geneList = factor(as.integer(unique.ap.wbid %in% unique.clust_2_wbid))
names(geneList) = unique.ap.wbid
BP.go = new("topGOdata", ontology='BP'
, allGenes = geneList
, annot = annFUN.gene2GO
, gene2GO = geneID2GO)

# algo weight01 performs a conditional traversal of the DAG
# BP.results.01f = runTest(BP.go, algorithm = "weight01", statistic="fisher")
# BP.results.k2.tab <- GenTable(object = BP.go, elimFisher = BP.results.01f, topNodes=20)
K2_allBPRes = GOSummary(BP.go)

#3
unique.clust_3_wbid = unique(ap_3$feature);
geneList = factor(as.integer(unique.ap.wbid %in% unique.clust_3_wbid))
names(geneList) = unique.ap.wbid
BP.go = new("topGOdata", ontology='BP'
, allGenes = geneList
, annot = annFUN.gene2GO
, gene2GO = geneID2GO)

# algo weight01 performs a conditional traversal of the DAG
# BP.results.01f = runTest(BP.go, algorithm = "weight01", statistic="fisher")
# BP.results.k3.tab <- GenTable(object = BP.go, elimFisher = BP.results.01f, topNodes=20)
K3_allBPRes = GOSummary(BP.go)

#4
unique.clust_4_wbid = unique(ap_4$feature);
geneList = factor(as.integer(unique.ap.wbid %in% unique.clust_4_wbid))
names(geneList) = unique.ap.wbid
BP.go = new("topGOdata", ontology='BP'
, allGenes = geneList
, annot = annFUN.gene2GO
, gene2GO = geneID2GO)

# algo weight01 performs a conditional traversal of the DAG
# BP.results.01f = runTest(BP.go, algorithm = "weight01", statistic="fisher")
# BP.results.k4.tab <- GenTable(object = BP.go, elimFisher = BP.results.01f, topNodes=20)
K4_allBPRes = GOSummary(BP.go)
```
