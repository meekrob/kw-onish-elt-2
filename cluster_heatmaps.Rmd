---
title: "Clustering of modENCODE/Reinke ChIP-seq peaks"
author: "DC King - Onish lab"
date: "Spring 2019"
output: html_document

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(root.dir='~/work/onish_ChIP_R_Analysis')
knitr::include_graphics
options(repos = c(CRAN = "http://cran.rstudio.com"))
if(!requireNamespace("ggExtra")) {
  install.packages("ggExtra");
}
```

## Script version
```{bash version, echo=FALSE}
cd ~/work/onish_ChIP_R_Analysis
git remote -v
git log -n 1
git status -s
```

## R version, libraries
```{r import}
R.version
library(pheatmap)
library(stringr)
library(reshape2)
library(ggplot2)
library(ggExtra)
library(RColorBrewer) # for pheatmap
library(GenomicRanges)
library(biomaRt)
library(ChIPpeakAnno)
library(topGO)
```

## Process data
```{r get-data}
getwd()
pth="allStagesUNION.IDR_0.05.sorted.bed_s.df"
df = read.table(pth, header=T, sep="\t")
all_max_col_ix = which(! is.na(str_match(colnames(df),"max")))
df_max = df[,all_max_col_ix]
all_nan_rows = apply(df_max, 1, function(x) { all(!is.finite(x))})
df_max = df_max[!all_nan_rows,]
df_max[is.na(df_max)] <- 0
colnames(df_max)<-c("max_log_L1_1_minus_log_L1_input", "max_log_L1_2_minus_log_L1_input", "max_log_L3_1_minus_log_L3_input", "max_log_L3_2_minus_log_L3_input", "max_log_LE_1_minus_log_LE_input",  "max_log_LE_2_minus_log_LE_input")
colnames_in_stage_order = colnames(df_max)[c(5,6,1:4)]
position_columns = c("chrom","chromStart","chromEnd","ID")
# make numeric, with 
data = as.matrix(df_max[,colnames_in_stage_order])
# perform normalization
peaks_sd = apply(data, 1, sd)
peaks_mu = apply(data, 1, mean)
# normalize by row
row_scaled_x = (data - peaks_mu) /  peaks_sd

# change filenames to shorter labels
colnames(row_scaled_x) <- c("LE_1", "LE_2", "L1_1", "L1_2", "L3_1","L3_2")

# changing versus not-changing
q.peaks_zeroed_nans_sd = function(q) { quantile(peaks_sd, q)}

THRESHOLD = .05

# make the text conversions consistent
TXT_THRESHOLD = sprintf("%.3f", THRESHOLD)
threshold_q = q.peaks_zeroed_nans_sd(THRESHOLD)
threshold_ix = peaks_sd > threshold_q
threshold_x = row_scaled_x[ threshold_ix,]

# df colnames differ from manual ones on line 44
excluded_set = df[! threshold_ix,c(position_columns, str_c(colnames_in_stage_order, "_z.bw"))]
excluded_filename = paste("allStagesUNION_max_sd_", TXT_THRESHOLD, "_0.bedlike", sep="")

# add the comment char to the first column
colnames(excluded_set) <- c("#chrom", colnames(excluded_set)[2:ncol(excluded_set)])
# write data file of excluded regions
# write.table(excluded_set, excluded_filename, quote=F, sep="\t", row.names=F)

print(paste("clustering with threshold", TXT_THRESHOLD, sep=" "))

nclust=4
set.seed(31415)
label=paste(sprintf("kmeans clusters at std. dev. > %.3f,", threshold_q), "(excludes lower ", sprintf("%.1f%%)", THRESHOLD*100))
pobj = pheatmap(threshold_x, kmeans=nclust, cluster_rows=F, cluster_cols = F, main=label)
kclusters = pobj$kmeans$cluster



### reorganize based on 4 meaningful trends
LEs = apply(pobj$kmeans$centers[,1:2],1, mean)#pobj$kmeans$centers[,1:2] 
L1s = apply(pobj$kmeans$centers[,3:4],1, mean)#pobj$kmeans$centers[,3:4] # 
L3s = apply(pobj$kmeans$centers[,5:6],1, mean)#pobj$kmeans$centers[,5:6] # 

sorted_k_order = order(LEs,L1s,L3s,decreasing=TRUE)
trend_labels = c("LE_specific", "L3_specific", "Dev_increasing",  "Post_embryonic")
k_remapping = data.frame(old=sorted_k_order,new=1:nclust,trend_label=trend_labels)

trends = cbind(LE=LEs,L1=L1s,L3=L3s)
trends_ordered = trends[order(LEs,L1s,L3s,decreasing=TRUE),]
rownames(trends_ordered) <- c("LE-specific", "L3-specific", "Increasing",  "Post embryonic")


trends_ordered_long = melt(trends_ordered)
colnames(trends_ordered_long) <- c("description", "stage", "center")

label=paste(sprintf("Cluster trends at std. dev. > %.3f,", threshold_q), "(excludes lower ", sprintf("%.1f%%)", THRESHOLD*100))
print(ggplot(trends_ordered_long, aes(x=stage,y=center, group=description,colour=description )) + geom_line(size = 1.5) + labs(title=label, y = "cluster center (Z)", x = "developmental stage"))  

## apply the new numbering to the data
reassigned_ks = rep(0,length(kclusters))
for (i in 1:4) {
  reassigned_ks[ kclusters == i] = k_remapping[i,2]
}


# prepare non-normalized output
# df colnames differ from manual ones on line 44
included_set = df[threshold_ix,c(position_columns, str_c(colnames_in_stage_order, "_z.bw"))]
split_non_normalized=split(included_set, kclusters)
sorted_k_remapping = k_remapping[order(k_remapping[[1]]),]


# Have the cluster numbers mean the same thing every time
for (k_i in names(split_non_normalized)) { 
  k_subset = split_non_normalized[[k_i]]
  trend_name = sorted_k_remapping[as.numeric(k_i), 'trend_label']
  kcluster_filename = paste("allStagesUNION_max_sd_", TXT_THRESHOLD, "_", trend_name, ".bedlike", sep="")
  print(kcluster_filename)
  write.table(k_subset, kcluster_filename, quote=F, sep="\t", row.names=F)
}
korder = order(reassigned_ks, decreasing=T)

# colorMap, needed to state explictly to agree with Deeptools plots
color = colorRampPalette(rev(brewer.pal(n = 7, name ="RdYlBu")))(100)
label=paste(sprintf("Clustered peaks, selecting std. dev. > %.3f,", threshold_q), "(excludes lower ", sprintf("%.1f%%)", THRESHOLD*100))
pheatmap(threshold_x[korder,], cluster_rows=F, cluster_cols=F, color=color, show_rownames=F, main=label)

# combine replicates to just get a single value per stage per peak
LE = (threshold_x[,'LE_1'] + threshold_x[,'LE_2'])/2
L1 = (threshold_x[,'L1_1'] + threshold_x[,'L1_2'])/2
L3 = (threshold_x[,'L3_1'] + threshold_x[,'L3_2'])/2
# make a value representing only the cluster
klabel = rep(-2, length(LE))
klabel[kclusters == 2] <-  -1
klabel[kclusters == 3] <-  1
klabel[kclusters == 4] <-  2

combined_x = data.frame(LE,L1,L3,k=klabel)
label=paste(sprintf("Clustered peaks, selecting std. dev. > %.3f,", threshold_q), "(excludes lower ", sprintf("%.1f%%)", THRESHOLD*100))

pheatmap(combined_x[korder,], cluster_rows=F, cluster_cols=F, color=color, show_rownames=F, main=label)

## recoup the original file, the normalized data, and the cluster assignment
# Going to add 7 columns: the normalized value for each stage (times 2 reps) plus the 
# cluster assignment

# normalized data
norm_LE_1 = rep(NA, nrow(df)); norm_LE_1[!all_nan_rows] = row_scaled_x[,1]
norm_LE_2 = rep(NA, nrow(df)); norm_LE_2[!all_nan_rows] = row_scaled_x[,2]
norm_L1_1 = rep(NA, nrow(df)); norm_L1_1[!all_nan_rows] = row_scaled_x[,3]
norm_L1_2 = rep(NA, nrow(df)); norm_L1_2[!all_nan_rows] = row_scaled_x[,4]
norm_L3_1 = rep(NA, nrow(df)); norm_L3_1[!all_nan_rows] = row_scaled_x[,5]
norm_L3_2 = rep(NA, nrow(df)); norm_L3_2[!all_nan_rows] = row_scaled_x[,6]

# kmeans cluster assignment
vec1 = rep(NA, nrow(row_scaled_x))
vec1[threshold_ix] = kclusters
kclust_mapping = rep(NA, nrow(df))
kclust_mapping[! all_nan_rows] = vec1

# sd and mean
sd_mapping = rep(NA, nrow(df))
sd_mapping[!all_nan_rows] = peaks_sd
mean_mapping = rep(NA, nrow(df))
mean_mapping[!all_nan_rows] = peaks_mu
ecdf_sd = ecdf(peaks_sd)

# peaks_quantile: this row is changing more (via sd) than peaks_quantile fraction of the dataset
peaks_quantile = rep(NA, nrow(df))
peaks_quantile[!all_nan_rows] = ecdf_sd(peaks_sd)
# combine new columns
new_df = data.frame(norm_LE_1,norm_LE_2,norm_L1_1,norm_L1_2,norm_L3_1,norm_L3_2,mean_mapping, sd_mapping, peaks_quantile,kclust_mapping)

# paste new columns onto original file
big_df = cbind(df, new_df)
big_df$kclust_mapping[is.na(big_df$kclust_mapping)] <- 0
# add the comment char to the first column
colnames(big_df) <- c("#chrom", colnames(big_df)[2:38])

# switch from DF to GRanges object
peaks = makeGRangesFromDataFrame(big_df, keep.extra.columns = T, starts.in.df.are.0based=T, seqnames.field = '#chrom')
ce11_info = Seqinfo(c('chrI', 'chrII', 'chrIII', 'chrIV', 'chrV', 'chrX'), c(15072434, 15279421, 13783801, 17493829, 20924180, 17718942), c(FALSE, FALSE, FALSE, FALSE, FALSE, FALSE), c("ce11", "ce11", "ce11", "ce11", "ce11", "ce11"))
seqinfo(peaks) <- ce11_info
# get gene assignment annotations
mart = useMart(biomart = "ENSEMBL_MART_ENSEMBL", host="grch37.ensembl.org", path="/biomart/martservice", dataset = "celegans_gene_ensembl")

ce_TSS = getAnnotation(mart, featureType = "TSS")
annotated_peaks = annotatePeakInBatch(peaks,mart, featureType = "TSS", AnnotationData = ce_TSS)
wbid=unlist(strsplit(names(annotated_peaks), "[.]"))[seq(2,2*length(annotated_peaks),by=2)]
annotated_peaks$WBID = wbid
unique.wbid = unique(wbid)
write.table(sort(unique.wbid), file="unique.wbid.txt", row.names=F,col.names=F,quote=F)

# genes per cluster
peaks_k0 = peaks[peaks$kclust_mapping == 0,]
clust_0_genes = annotatePeakInBatch(peaks_k0, mart, featureType = "TSS", AnnotationData = ce_TSS)
clust_0_wbid = unlist(strsplit(names(clust_0_genes), "[.]"))[seq(2,2*length(clust_0_genes),by=2)]
unique.clust_0_wbid = unique(clust_0_wbid)
write.table(sort(unique.clust_0_wbid), file="unique.clust_0_wbid.txt", row.names=F,col.names=F,quote=F)

peaks_k1 = peaks[peaks$kclust_mapping == 1,]
clust_1_genes = annotatePeakInBatch(peaks_k1, mart, featureType = "TSS", AnnotationData = ce_TSS)
clust_1_wbid = unlist(strsplit(names(clust_1_genes), "[.]"))[seq(2,2*length(clust_1_genes),by=2)]
unique.clust_1_wbid = unique(clust_1_wbid)
write.table(sort(unique.clust_1_wbid), file="unique.clust_1_wbid.txt", row.names=F,col.names=F,quote=F)

peaks_k2 = peaks[peaks$kclust_mapping == 2,]
clust_2_genes = annotatePeakInBatch(peaks_k2, mart, featureType = "TSS", AnnotationData = ce_TSS)
clust_2_wbid = unlist(strsplit(names(clust_2_genes), "[.]"))[seq(2,2*length(clust_2_genes),by=2)]
unique.clust_2_wbid = unique(clust_2_wbid)
write.table(sort(unique.clust_2_wbid), file="unique.clust_2_wbid.txt", row.names=F,col.names=F,quote=F)

peaks_k3 = peaks[peaks$kclust_mapping == 3,]
clust_3_genes = annotatePeakInBatch(peaks_k3, mart, featureType = "TSS", AnnotationData = ce_TSS)
clust_3_wbid = unlist(strsplit(names(clust_3_genes), "[.]"))[seq(2,2*length(clust_3_genes),by=2)]
unique.clust_3_wbid = unique(clust_3_wbid)
write.table(sort(unique.clust_3_wbid), file="unique.clust_3_wbid.txt", row.names=F,col.names=F,quote=F)

peaks_k4 = peaks[peaks$kclust_mapping == 4,]
clust_4_genes = annotatePeakInBatch(peaks_k4, mart, featureType = "TSS", AnnotationData = ce_TSS)
clust_4_wbid = unlist(strsplit(names(clust_4_genes), "[.]"))[seq(2,2*length(clust_4_genes),by=2)]
unique.clust_4_wbid = unique(clust_4_wbid)
write.table(sort(unique.clust_4_wbid), file="unique.clust_4_wbid.txt", row.names=F,col.names=F,quote=F)

# upset plot: identify set overlap by assigned value of k

clustersPerGene = table(annotated_peaks$WBID, annotated_peaks$kclust_mapping)
wbid_rownames = rownames(clustersPerGene)
# some bool vectors
wbid_names_k0_bool = clustersPerGene[,'0'] > 0
wbid_names_k1_bool = clustersPerGene[,'1'] > 0
wbid_names_k2_bool = clustersPerGene[,'2'] > 0
wbid_names_k3_bool = clustersPerGene[,'3'] > 0
wbid_names_k4_bool = clustersPerGene[,'4'] > 0

wbid_clusters= list(k0=wbid_rownames[wbid_names_k0_bool],k1=wbid_rownames[wbid_names_k1_bool],k3=wbid_rownames[wbid_names_k3_bool], k4=wbid_rownames[wbid_names_k4_bool])


upset(fromList(wbid_clusters),sets=c("k0","k1","k2","k3","k4"), order.by = "freq", mainbar.y.label = "Geneset intersections", sets.x.label="# of genes in cluster", set_size.show=T,group.by="sets",text.scale=1.5,keep.order = T,query.legend = "top", nintersects=100)

clustersPerGene_rowSums = rowSums(clustersPerGene)
multiple_peaks = clustersPerGene_rowSums > 1
sum(multiple_peaks) # 1740
rowMaxes = function(x) apply(x, 1, max)
clustersPerGene_rowMaxes = rowMaxes(clustersPerGene)
multiple_clusters = multiple_peaks & clustersPerGene_rowMaxes != clustersPerGene_rowSums
sum(multiple_clusters) # 1177

clustersPerGene_canberra = dist(clustersPerGene, method = "can")
clustersPerGene_canberra_hclust = hclust(clustersPerGene_canberra)
clust_labels = paste0(clustersPerGene[,1],clustersPerGene[,2],clustersPerGene[,3],clustersPerGene[,4],clustersPerGene[,5])
#plot(clustersPerGene_canberra_hclust, labels=clust_labels,cex=.33)
```

``` {r GO term analysis}
# get the annotations from PARASITE
if (! "paramart" %in% ls()) {
  paramart <- useMart("parasite_mart", dataset = "wbps_gene", host = "https://parasite.wormbase.org", port = 443)}
if (! "WORMGO" %in% ls()) {
  # go to https://parasite.wormbase.org/biomart/martview/ to figure out the values to use for this
  WORMGO=biomaRt::getBM(mart = paramart, filter="species_id_1010", value="caelegprjna13758",
       attributes = c( "wbps_gene_id", 
            "external_gene_id", 
            "go_accession", 
            "go_name_1006", 
            "go_linkage_type")) 
}




# All possible genes
all.genes <- unique(as.character(WORMGO$wbps_gene_id))
geneList = factor(as.integer(all.genes %in% ap_wbid))
names(geneList) = all.genes

BP.go = new("topGOdata", ontology='BP'
, allGenes = geneList
, annot = annFUN.gene2GO
, gene2GO = geneID2GO)

MF.go = new("topGOdata", ontology='MF'
, allGenes = geneList
, annot = annFUN.gene2GO
, gene2GO = geneID2GO)

CC.go = new("topGOdata", ontology='CC'
, allGenes = geneList
, annot = annFUN.gene2GO
, gene2GO = geneID2GO)

GOSummary<- function(GOdata) {
  test.stat <- new("classicCount", testStatistic = GOFisherTest, name = "Fisher test")
  resultFis <- getSigGroups(GOdata, test.stat)
  test.stat <- new("classicScore", testStatistic = GOKSTest, name = "KS tests")
  resultKS <- getSigGroups(GOdata, test.stat)
  test.stat <- new("elimCount", testStatistic = GOFisherTest, name = "Fisher test",cutOff = 0.01)
  resultElim <- getSigGroups(GOdata, test.stat)
  test.stat <- new("weightCount", testStatistic = GOFisherTest, name = "Fisher test", sigRatio = "ratio")
  resultWeight <- getSigGroups(GOdata, test.stat)
  l <- list(classic = resultFis, KS = resultKS, elim = resultElim,weight = resultWeight)
  return(GenTable(object=GOdata, weight=l$weight, classic=l$classic, elim=l$elim, KS=l$KS, orderBy="weight",ranksOf = "classic", topNodes = 50))
}

## algorithm weight01 performs a traversal of the DAG 
# BP.results.01f = runTest(BP.go, algorithm = "weight01", statistic="fisher")
# peakset.BP.results.tab <- GenTable(object = BP.go, elimFisher = BP.results.01f)
# showSigOfNodes(BP.go, score(BP.results.01f),useInfo = 'all' ,firstSigNodes = 10)
# 
# MF.go = new("topGOdata", ontology='MF'
# , allGenes = geneList
# , annot = annFUN.gene2GO
# , gene2GO = geneID2GO)
# GOdata=MF.go
# MF.results <- runTest(MF.go, algorithm = "weight01", statistic = "fisher")
# MF.results.tab <- GenTable(object = MF.go, elimFisher = MF.results)
# 
# 
# CC.go = new("topGOdata", ontology='CC'
# , allGenes = geneList
# , annot = annFUN.gene2GO
# , gene2GO = geneID2GO)
# GOdata = CC.go
# CC.results <- runTest(CC.go, algorithm = "weight01", statistic = "fisher")
# CC.results.tab <- GenTable(object = CC.go, elimFisher = CC.results, topNodes=20)

# Sub clusters vs all peaks
#0
geneList = factor(as.integer(wbid %in% unique.clust_0_wbid))
names(geneList) = wbid
BP.go = new("topGOdata", ontology='BP'
, allGenes = geneList
, annot = annFUN.gene2GO
, gene2GO = geneID2GO)

#BP.results.01f = runTest(BP.go, algorithm = "weight01", statistic="fisher")
#BP.results.k0.tab <- GenTable(object = BP.go, elimFisher = BP.results.01f, topNodes=20)
K0_allBPRes = GOSummary(BP.go)

#1
geneList = factor(as.integer(wbid %in% unique.clust_1_wbid))
names(geneList) = wbid
BP.go = new("topGOdata", ontology='BP'
, allGenes = geneList
, annot = annFUN.gene2GO
, gene2GO = geneID2GO)

# algo weight01 performs a conditional traversal of the DAG
#BP.results.01f = runTest(BP.go, algorithm = "weight01", statistic="fisher")
#BP.results.k1.tab <- GenTable(object = BP.go, elimFisher = BP.results.01f, topNodes=20)
K1_allBPRes = GOSummary(BP.go)

#2
geneList = factor(as.integer(wbid %in% unique.clust_2_wbid))
names(geneList) = wbid
BP.go = new("topGOdata", ontology='BP'
, allGenes = geneList
, annot = annFUN.gene2GO
, gene2GO = geneID2GO)

# algo weight01 performs a conditional traversal of the DAG
# BP.results.01f = runTest(BP.go, algorithm = "weight01", statistic="fisher")
# BP.results.k2.tab <- GenTable(object = BP.go, elimFisher = BP.results.01f, topNodes=20)
K2_allBPRes = GOSummary(BP.go)

#3
geneList = factor(as.integer(wbid %in% unique.clust_3_wbid))
names(geneList) = wbid
BP.go = new("topGOdata", ontology='BP'
, allGenes = geneList
, annot = annFUN.gene2GO
, gene2GO = geneID2GO)

# algo weight01 performs a conditional traversal of the DAG
# BP.results.01f = runTest(BP.go, algorithm = "weight01", statistic="fisher")
# BP.results.k3.tab <- GenTable(object = BP.go, elimFisher = BP.results.01f, topNodes=20)
K3_allBPRes = GOSummary(BP.go)

#4
geneList = factor(as.integer(wbid %in% unique.clust_4_wbid))
names(geneList) = wbid
BP.go = new("topGOdata", ontology='BP'
, allGenes = geneList
, annot = annFUN.gene2GO
, gene2GO = geneID2GO)

# algo weight01 performs a conditional traversal of the DAG
# BP.results.01f = runTest(BP.go, algorithm = "weight01", statistic="fisher")
# BP.results.k4.tab <- GenTable(object = BP.go, elimFisher = BP.results.01f, topNodes=20)
K4_allBPRes = GOSummary(BP.go)
```
